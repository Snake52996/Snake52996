<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[来讲个故事吧]]></title>
    <url>%2F2018%2F04%2F06%2F%E6%9D%A5%E8%AE%B2%E4%B8%AA%E6%95%85%E4%BA%8B%E5%90%A7%2F</url>
    <content type="text"><![CDATA[来讲一个故事吧. 曾经,在五年前,一个刚从小学毕业的人,稀里糊涂的在他莫名其妙的考上的一所著名的中学(BJ的强校,无论实际如何,至少这么说)报名了一个叫算法什么东西的面向初一新生的夏令营.他的故事就从这里开始了. 他报名的原因很简单,也不会出乎谁的预料.他看上了这个夏令营活动的时候能够使用电脑.他热爱游戏.但是家里人都颇为反对.因此他希望在这里能不被家长干扰的玩游戏——老师算什么嘛. 事情不完全像他想象的那样.他确实在这里得到了不少享受游戏的时间,但是他也不得不学习了一些叫做C++的东西.他一开始对这个不怎么感兴趣,毕竟什么能比的上游戏啊.慢慢的,他开始感到这个东西有一点意思.但他依然把重点放在了游戏上. 夏天转瞬而过,他成为了新学校的学生.他毫不犹豫的加入了夏令营的延续——信息学竞赛培训的课程,占用周六的下午半天.当然,还是为了游戏. 他和几个同学曾经在周六上午的数学课结束后一路狂奔赶着坐地铁,再一路狂奔跑进机房,曾经为了打开老师刻意迟开的门而合力把一个同学从墙上方的窗口扔进机房让他开门,就是为了多玩十几分钟的游戏.那个时候的他感觉很开心.竞赛是什么?似乎只是这个周六下午的课程的名字而已.]]></content>
      <tags>
        <tag>胡言乱语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1036-选数]]></title>
    <url>%2F2018%2F04%2F06%2F%E9%A2%98%E8%A7%A3-P1036-%E9%80%89%E6%95%B0%2F</url>
    <content type="text"><![CDATA[这是从洛谷搬来的我之前写的博客,题解 P1036 选数,因此存在一些在当前环境下难以理解的措辞,请直接忽视,我也不改了.这是一道极水的题,但是再怎么说也是我曾经写过的题解,没有不搬过来的道理. 本人大概是最弱的红名了吧(还是改了,现在是红名了)…一条咸鱼看着周围的大佬们瑟瑟发抖…. 进入正题.这道题暴搜居然没有TLE,心情大好,来发篇题解,希望能帮上有需要的人的忙. 既然放在了过程函数和递归中,首先想到的就是用递归解决.首先考虑得到了一个和,如何判断它是不是质数?朴素方法,设这个数为n,从2至n-1,依此判断是否能整除n,如果发现存在某个整数能够整除n,那么n不是质数,否则是.显然循环次数规模与n相同. 简单优化,显然一个整数n若可以用两个整数的乘积表示,那么其中小一点的约数不会超过$\sqrt{n}$.我们以$60$为例 (试图隐藏我不打算证明的事实) : 60=1*60=2*30=3*20=4*15=5*12=6*10=10*6=.. 显然,当超过$\sqrt{60}=7$时开始前面的数就是较大的约数了.因此,可以将枚举范围缩小到$[2,\sqrt{n}]$,时间复杂度降低到$O(\sqrt{n})$.简要代码如下:123456bool isp(int a)//返回a是否为质数&#123; int sq=sqrt(a);//调用函数求a的算术平方根.注意sqrt()函数在cmath中.提前算出可以避免每次循环都计算一次a的算术平方根,可以减小常数 for(int i=2;i&lt;=sq;i++) if(a%i==0) return false; return true;&#125; 考虑可能需要进行多次判断,即使如此优化仍可能超时,考虑一个更优的方法:注意到相加得到的和最大不超过$1\times10^7$,可以构造一个质数表,每次检查n是否为质数只需要查表即可.如何构造一个这样的质数表呢?显然由质数的定义可以得到,一个质数的任意整倍数(除其自身外)都不是质数,任意一个整数都可以被表示为某(几)个质数的乘积,也就是说任意的整数都是某(几)个质数的整倍数.因此只需将任意一个质数的二倍及以上的整倍数标记为”非质数”,就可以获得这样的一张质数表了.简要代码如下:12345678const int MAX=10000010;bool notp[MAX];//质数表,当notp[i]==0时i为质数.注意开够空间void calp(void)//开始构造质数表&#123; for(int i=2;i&lt;MAX;i++) if(!notp[i]) for(int j=i+i;j&lt;MAX;j+=i) notp[j]=1;//当前的i是质数,因此将其所有二倍及以上的整倍数都设为非质数.注意不要越界 return;&#125; 这样一来就更优了.简单 (胡乱) 分析一波:外层循环将重复约$1\times10^7$次,若$i$不是质数则内层将仅进行$1$次判断,否则在判断后还将进行约$(1\times10^7-i)/i$次赋值操作.实验证明 (再次尝试隐藏自己不打算推式子的事实) ,该函数的循环仅会运行$3.95\times10^7$次,反复改变MAX的值可以发现运行次数与MAX的一次方成正比,即该方法可以在线性时间内构造质数表.为了确认自己已经理解了这一部分,建议先前去完成P3383 【模板】线性筛素数. 事实上,还可以再做两个小小的改变,进一步提高这个算法的效率.外层的for(int i=2;i&lt;MAX;i++)可以修改为for(int i=2;i&lt;sqrt(MAX);i++),而内层的for(int j=i+i;j&lt;MAX;j+=i)可以修改为for(int j=i*i;j&lt;MAX;j+=i).当然,建议将修改后的外层的条件修改为i&lt;LIM,并在循环外加上int LIM=sqrt(MAX);,来避免重复计算带来的时间开销.这两处改动的正确性很显然,可以自己证咯. 到目前为止,我们获得了初始化时间复杂度为$O(n)$,查询时间复杂度为$O(1)$的质数表.下面,我们尝试回到原来的问题,看看我们还缺些什么. 我们需要从n个数中选出k个并计算它们的和.为了暴搜,我们需要寻找一种方法唯一地定义当前状态.很容易想到需要一个集合E表示已选择的数.可以用一个数组visited,标记所有已选的数的visited为1.像是这样:1234//假设选了ivisited[i]=1;cal();//递归调用visited[i]=0;//还原确保之后不会漏选某种情况 可以很容易的利用visited统计已选的数的个数和和.看起来不错.但是不要容易确保不会选重的同时不选漏.比如 a[1]+a[2]+a[5],a[5]+a[2]+a[1] 而且每次查找visited也不够优美,应该还有更简单的解决办法. 很容易注意到,每次只向后看是不会漏选的.举例,如当前选到的数中下标最大的是low,那么选下一个数的时候只从下标为$[low+1,n]$的数中选不会导致缺失情况也不会导致重复 (依然不证明) ,因此可以重新定义当前状态:还须选i个数,当前的和为sum,当前已经看完了下标为k及以前的数.这样就确保了每次不需要检查重复的情况,也不需要管具体选择了哪些书,只要一一枚举k以后的数并递归调用就可以了,极大的简化了问题. 递归边界也不难得出:当还须选0个数的时候,已经选够了,判断当前的和是否为质数,如果是返回1,否则返回0.而非边界的时候则进行枚举,计算所有情况得到的返回值的和并返回,我们的函数返回值即使在当前限定条件下(从下标大于k的数中选i个数,在sum的基础上加上选的数的和结果是质数)的情况数.显然在主函数中调用cal(k,0,0)得到的返回值即为结果(注意,这里的k与函数中的k含义不同,此处于题目描述一致,请仔细确认不同k的含义). 最后还有一个小小的可行性剪枝:若cal函数中发现$n-k&lt;i$则返回0.为了确认理解了k的含义,请自行思考理由. 附上AC代码(上面解释过的部分此处不再加注释):1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;//虽然使用的是c++,但由于c的输入输出更快,倾向于使用c的输入输出using namespace std;const int MAX=10000010;bool notp[MAX];int a[25];//保存数据int n;//函数中需要使用,为了方便设为全局变量void calp(void)&#123; for(int i=2;i&lt;MAX;i++) if(!notp[i]) for(int j=i+i;j&lt;MAX;j+=i) notp[j]=1; return;&#125;int cal(int i,int sum,int k) //再选i个,当前和为sum,看完了a[k]&#123; if(i==0) &#123; if(notp[sum]) return 0; else return 1; &#125; if(n-k&lt;i) return 0; int ans=0; for(int j=k+1;j&lt;=n;j++) ans+=cal(i-1,sum+a[j],j); return ans;&#125;int main()&#123; calp(); int k; //关于输入输出的问题请自行查找资料/请教他人解决 scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",a+i); printf("%d",cal(k,0,0)); return 0;&#125; 至此,虽然并没有使用更高效率的方法,我们依然以尚可以接受的时间通过了这道题.强烈建议再去完成P1706 全排列问题,使用类似的方法完成一道题可以加深理解. 补充一下,还有一道更进阶的题目P1691 有重复元素的排列问题 最后,本人蒟蒻一棵 (棵?),有不准确的地方请…用力喷!我会回来改正的. Ps.现在看来当初自己写了些什么东西啊…恥ずかしい… 以上.]]></content>
      <tags>
        <tag>题解</tag>
        <tag>暴力</tag>
        <tag>搜索</tag>
        <tag>模拟</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[省选前的挣扎]]></title>
    <url>%2F2018%2F04%2F06%2F%E7%9C%81%E9%80%89%E5%89%8D%E7%9A%84%E6%8C%A3%E6%89%8E%2F</url>
    <content type="text"><![CDATA[省选马上就要到了.距离退役只剩下不到一周了.大概(肯定)是要凉了.我知道.但是即使如此我也要在结束前挣扎,挣扎到结束.很愚蠢,是的.来记录一下这些天我都做了些什么题,学了些什么东西吧. 学习的知识 学会了的 可持久化线段树 Trie 可持久化Trie 后缀数组 卢卡斯定理 正在学的 分块 莫队算法 点分治(淀粉质) 还要学的 Splay LCT 模拟退火 乱七八糟的其他东西(毕竟学会的越多越好) 做题列表 2018/4/3 P3919 【模板】可持久化数组(可持久化线段树/平衡树) 模板(问题不大) 2018/4/4 HDU1251 统计难题 trie(问题不大) UVA11362 Phone List trie(问题不大) P3809 【模板】后缀排序 模板(问题很大) P3807 【模板】卢卡斯定理 模板(问题不大) T24743 永世隔绝的理想乡 模拟,坑题(没问题) 2018/4/5 P1691 有重复元素的排列问题 STL函数应用(滑稽) P3414 SAC#1 - 组合数 二项式定理(没问题) P1869 愚蠢的组合数 Lucas定理(应该没问题了) BNUOJ53080 塞特斯玛斯塔 模拟(滑稽) T23806 Sum of a and b 模拟,坑题(滑稽) T26520 Saberの暖心福利 模拟(滑稽) T26021 凛の车厢重组 归并排序,逆序对(应该没问题) T26020 Archerの第K小数 计数排序(没问题) T26019 凛の数字统计 Treap平衡树(应该问题) T25221 SaberのA+B问题 模拟,大整数加法(没问题) 2018/4/6 T26018 Archerの昆虫繁殖 模拟(没问题) T26551 lyf and Archerの作业 模拟,坑题(没问题) T26544 有趣の数列之233 模拟,猜测题意(没问题) T26553 Saberの骑士之战 链表,模拟(现在应该没问题) A + B Problem 线性筛质数,模拟,坑题(应该没问题) 野兽先辈万物说 字符串处理,哈希,并查集(应该没问题) 2018/4/7 U23063 质数 数论,哥德巴赫猜想(应该没问题) U????? 函数 数论,瞎搞(胡乱一通瞎搞就AC了我也是一脸懵)]]></content>
      <tags>
        <tag>胡言乱语</tag>
        <tag>归纳总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可持久化线段树]]></title>
    <url>%2F2018%2F04%2F03%2F%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[刚刚学习了可持久化线段树,AC了洛谷上的模板题,来总结一波这个看似复杂的数据结构吧(其实一点也不难的,我这么弱都一遍写对了). umm…]]></content>
      <tags>
        <tag>题解</tag>
        <tag>未完成</tag>
        <tag>数据结构</tag>
        <tag>可持久化</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018北京集训队游记]]></title>
    <url>%2F2018%2F04%2F01%2F2018%E5%8C%97%E4%BA%AC%E9%9B%86%E8%AE%AD%E9%98%9F%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[晚年竞赛选手终于在自己离开OI世界之前来了一次集训队。当然要记录一番咯。来写一篇游记吧。 Day1今年北京的集训队培训在首师大附中。我这个蒟蒻是第一次去首师大附（据说之前好几次都是在这），还好学校的（行进路线涉及到的）建筑结构并不复杂，并没有迷路。 到了机房，纠结了半天找了个地方坐下，面对着电脑屏幕不知道该干什么。找不着机箱诶（后来才知道机箱装在桌子下面的柜子里，从开的洞摸进去就能按到电源键）。终归还是等了老师远程开机2333。 集训队见面就考试诶（虽然是模拟）。一共三道题，见到了继洛谷“三连击”之后的第二道提交答案题。虚的不行，我太蒻了。 啊,我找不到比较优美的方法来展示题面了.等有时间再来弄吧,回头一定给自己的博客加上PDF浏览器.现在先用云盘凑合吧.坚果云还算好用,只是必须要注册才能查看文件.有时间再找更好的吧.点击这里传送 T1 面试umm似乎还没有找到能有效地在这里直接展示题面的方法. 这道题第一眼看上去，没思路。再仔细看看，似乎有点像单调队列的思想。想到了把身高和位置打包排序的思路。仔细想想似乎没问题，就敲了。把身高作为主关键字，序号作为次关键字，从小到大排序，之后从左到右遍历，这样考察的动态区间中最后的人（当前看到的）一旦比区间最靠前的高超过k，就可以删除最靠前的人了，从而保证由左右指针决定的区间之内的人都满足身高差不超过的条件。 之后统计。一开始想的是统计遍历过程中见过的最靠后出现的人出现的时间（显然有问题，但是当时居然没意识到）。结果过了三个样例（奇水无比）。第四个点出了问题，立刻意识到了问题所在。 想明白了似乎有些人虽然考察过了，但是有可能已经不在满足条件的区间内了。比如一个很矮的人最后一个出现，他不会被选上，但是会被统计为选上的人中最后出现的人。于是改了一下，每次统计符合条件区间中的最后出现的人是第几个出现的，之后和当前答案比较，如果更小则更新。然而还是有问题。区间中的人可能多于要选的人数m，我们只应该找出其中最早出现的m个人，他们中最晚出现的人出现的时间就是答案。而我统计的是区间中所有人的最晚出现时间，当然是有问题的。 找到了问题，下面就是修改咯。动态区间第K大，是不是非常眼熟？显然，一个Treap的问题。然而我对写平衡树是颇为拒绝的。太麻烦的，当初调了好几天呢。花费了一段时间（大概5分钟）说服自己，我终于还是码了个Treap。每次区间扩张，将新加入的人的序号插进树里；每次人移出区间，从树上删除；每次符合条件的人够了m，查询区间第m大。非常直观（跑）。结果万万没想到，居然都没用调，一次就写过了。于是就AC了。 后来听讲评，根本就不用平衡树。直接二分答案之后检查是否满足条件就可以了。检查只要预先像我的方法一样排一遍序，检查的时候记得跳过还没出现的人就行了。编码复杂度远小于我的。还真的是我好蒻啊。终于明白什么叫学数据结构学傻了。 T2 二次求和]]></content>
      <tags>
        <tag>胡言乱语</tag>
        <tag>题解</tag>
        <tag>游记</tag>
        <tag>随笔</tag>
        <tag>未完成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有用的工具]]></title>
    <url>%2F2018%2F03%2F31%2F%E6%9C%89%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[来总结一些有用的(有意思的)工具.先胡乱分类吧,毕竟东西少.等东西多了再仔细考虑分类. 图示工具(什么鬼名啊,我果然对起名没半点思路) csacademy/grapheditor:一个在线的图生成模块,可以根据输入快速生成一张图,还可以一键生成成树的形状. 让我帮你百度一下 生成一个链接,可以展示一个动画嘲讽不会百度的人,然后给他百度…(这真是OI工具吗…) 博客用到的工具 simimg 一个图床.免费的.感觉界面也很友好,还没怎么用呢.如果好用以后这个博客的图床就用这个了.]]></content>
      <tags>
        <tag>工具</tag>
        <tag>奇技淫巧</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大流算法之ISAP]]></title>
    <url>%2F2018%2F03%2F30%2F%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AE%97%E6%B3%95%E4%B9%8BISAP%2F</url>
    <content type="text"><![CDATA[网络流(最大流)实在是个玄而又玄的东西.就是一个异常简单的模型,可以想象成是一个管道网络,各个管道有各自的单位时间最大通过的流量,问单位时间从其中某一个点(源点)到另一个点(汇点)能通过的最大流量.但是这个东西却能解决很多问题,其中的一些问题甚至看起来还和这个模型没啥关系,但是巧妙地构建关系建立出一张图之后就会发现,这玩意居然能用最大流的思想解. 因此,掌握一种快速求解最大流问题的算法就异常重要了.大名鼎鼎的 Ford-Fulkerson算法 的效率过低, EdmondsKarp算法 虽有改进但是依然不够,直到 Dicnic算法 运用类似启发式搜索的思想将时间复杂度降低到$O(V^2E)$,才刚刚称得上是比较高效.而在此基础上,采用类似思路的 ISAP算法 则使用了动态的层次图,省略了Dicnic算法中BFS的过程,效率进一步提高(虽然理论的时间复杂度没有改变,仍然是$O(V^2E)$). 虽然初次用ISAP水过了洛谷的 最大流模板题 ,但是依然担心自己还是没有掌握,于是在这里总结一下. 前置知识ISAP的代码很简单,在Dicnic的基础上也比较容易理解.因此再研究ISAP之前要先研究这些: 网络流的基本概念 Dicnic算法 链式前向星(邻接链表) ISAP的基本思想ISAP的思路的Dicnic是几乎一样的,生成(计算)每个节点的高度,层次(定义为当前节点到汇点的最短距离),搜索中每次前进只会走到高度比当前节点低1的节点,因此能保证总是向着汇点前进的,避免了向着反方向或是同层访问一些多余的节点,是典型的启发式搜索. 那么就会遇到一个问题:如果在某个节点,我们发现无路可走了,怎么办?如果是这个点不可能再向它连接的其他节点发送流量了,那么似乎还没有什么问题;如果无路可走是因为高度的限制,会不会损失一部分解? 这就是ISAP的核心:重贴标签.当我们发现出现了这种情况,我们重新标记当前节点的高度.为了不漏掉某些解,显然我们应该将它的高度设为比它连接的且边上还有富裕容量的节点中高度最小的节点大1.这就是所谓的 重贴标签. 具体实现]]></content>
      <tags>
        <tag>未完成</tag>
        <tag>算法</tag>
        <tag>图</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读写挂测试&怀疑人生]]></title>
    <url>%2F2018%2F03%2F25%2F%E8%AF%BB%E5%86%99%E6%8C%82%E6%B5%8B%E8%AF%95%26%E6%80%80%E7%96%91%E4%BA%BA%E7%94%9F%2F</url>
    <content type="text"><![CDATA[众所周知,在信息题目中,有一个非常令人头疼的问题就是TLE.同样众所周知的还有一个词语,叫做卡常数.就像这样: “这道题时间复杂度没问题,怎么调都TLE” “卡卡常就过了/优化优化常数就过了” 然而,有时会被针对,即使主要过程中的复杂度和常数都很优,读入的过程就已经足以使得你的程序TLE.这时候就需要读写优化了. 经验告诉我们…一般来说,c++中的各种方式进行读写的速度对比是这样的:v(cin,cout)&lt;v(cin,cout(关闭流同步))&lt;v(scanf,printf)&lt;v(读写挂).针对这一点,我进行了一些测试(然后开始怀疑人生) 生成数据我采用了一个极为简单的程序随机生成$10^6$个整数存入文件,作为测试用的数据.程序代码如下: 1234567891011#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;using namespace std;int main()&#123; srand(time(0)); freopen("data.in","w",stdout); for(int i=1;i&lt;=1000000;i++) printf("%d ",rand()); return 0;&#125; 对cin与cout进行测试首先我使用cin和cout对测试数据进行读入并立刻输出至标准输出,用ctime中的clock()函数计时,并将运行时间写入文件.代码如下: 123456789101112131415161718#include&lt;fstream&gt;#include&lt;iostream&gt;#include&lt;ctime&gt;using namespace std;ifstream fin("data.in");ofstream fout("test1.out");int main()&#123; double time0=clock(); int tmp; for(int i=1;i&lt;=1000000;i++) &#123; fin&gt;&gt;tmp; cout&lt;&lt;tmp&lt;&lt;" "; &#125; fout&lt;&lt;"Cost "&lt;&lt;(int)((clock()-time0)/CLOCKS_PER_SEC*1000)&lt;&lt;"ms."&lt;&lt;endl; return 0;&#125; 在测试后我得到了这样的结果: Cost 129151ms. 共花费了129151毫秒,约129秒,2分钟. 对关闭流同步的cin与cout进行测试我同样使用cin和cout对测试数据进行读入并立刻输出至标准输出,用ctime中的clock()函数计时,并将运行时间写入文件,但这次在开始之前我先关闭了cin,cout与stdio的同步,因为这个同步操作将带来不小的时间开销.代码如下: 12345678910111213141516171819#include&lt;fstream&gt;#include&lt;iostream&gt;#include&lt;ctime&gt;using namespace std;ifstream fin("data.in");ofstream fout("test2.out");int main()&#123; ios::sync_with_stdio(false); //关闭流同步 double time0=clock(); int tmp; for(int i=1;i&lt;=1000000;i++) &#123; fin&gt;&gt;tmp; cout&lt;&lt;tmp&lt;&lt;" "; &#125; fout&lt;&lt;"Cost "&lt;&lt;(int)((clock()-time0)/CLOCKS_PER_SEC*1000)&lt;&lt;"ms."&lt;&lt;endl; return 0;&#125; 在测试后我得到了这样的结果: Cost 1640ms. 共花费了1640毫秒,约2秒. 对scanf与printf进行测试这次使用scanf和printf对测试数据进行读入并立刻输出至标准输出,同样用ctime中的clock()函数计时,并将运行时间写入文件.代码如下: 1234567891011121314151617#include&lt;cstdio&gt;#include&lt;ctime&gt;int main()&#123; FILE* fin=fopen("data.in","r"); FILE* fout=fopen("test3.out","w"); double time0=clock(); int tmp; for(int i=1;i&lt;=1000000;i++) &#123; fscanf(fin,"%d",&amp;tmp); printf("%d ",tmp); &#125; fprintf(fout,"Cost %dms.\n",(int)((clock()-time0)/CLOCKS_PER_SEC*1000)); return 0;&#125; 在测试后我得到了这样的结果: Cost 216750ms. 共花费了216750毫秒,约217秒,近4分钟. 事情的进展开始超出了我的想象. 对读写挂的测试最后我对自己写的读写挂进行了读写测试.读写挂使用getchar(void)和putchar(int _Ch)函数进行读写,这两个函数的工作速度更快,但是一次只能对一个字符进行读或写.同样从文件中读入,立刻输出至标准输出,但这次的运行时间被输出至了标准输出.虽然不甚科学,但不会对数据产生太大的影响. 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;ctime&gt;inline void get_int(int&amp; a)&#123; char c=getchar(); bool flag=0; while(c!='-' &amp;&amp; (c&lt;'0' || c&gt;'9')) c=getchar(); if(c=='-') &#123; flag=1; c=getchar(); &#125; a=0; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123; a*=10; a+=c-'0'; c=getchar(); &#125; a=flag?-a:a; return;&#125;void put_int(int a)&#123; if(a&lt;0) &#123; putchar('-'); a=-a; &#125; if(a&gt;9) put_int(a/10); putchar('0'+a%10); return;&#125;inline void end_line(void)&#123;putchar('\n');&#125;inline void put_char(const char a[])&#123; for(int i=0;a[i]!='\0';i++) putchar(a[i]); return;&#125;int main()&#123; freopen("data.in","r",stdin); int tmp; double time0=clock(); for(int i=1;i&lt;=1000000;i++) &#123; get_int(tmp); put_int(tmp); putchar(' '); &#125; put_char("Cost "); put_int((int)((clock()-time0)/CLOCKS_PER_SEC*1000)); put_char("ms.\n"); return 0;&#125; 测试结果是这样的: Cost 142303ms. 共花费了142303毫秒,约142秒,超过2分钟. 对比&amp;总结最终得到的时间数据告诉我们,实际上的速度是这样的: v(scanf,printf)&lt;v(读写挂)&lt;v(cin,cout)&lt;v(cin,cout(关闭流同步)) 不禁开始怀疑人生.现在还没有找到问题所在,或许是我的读写挂太丑了?我查找了其他人写的读写挂,大部分和我的大同小异,应该没有太大影响. 等找到问题所在再来更新这篇文章吧.如果您有什么高见,请务必留下评论,感谢!本蒟蒻在此鞠躬.]]></content>
      <tags>
        <tag>胡言乱语</tag>
        <tag>奇技淫巧</tag>
        <tag>实验</tag>
        <tag>读写优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树链剖分学习笔记]]></title>
    <url>%2F2018%2F03%2F25%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前些日子在洛谷上写LCA的时候用倍增算法被卡常数了,一气之下就去查了其他的LCA算法,看到tarjan和树剖都能解决这个问题,于是就选择了学习树剖这条(不归之)路. 以上全是废话 我看了很多大犇的博客才终于大概搞明白了树链剖分是个什么逻辑和思路.虽然大犇们写的都很详细了,但对于本蒟蒻来说还是有些不那么容易理解,因此在这里尝试自己重新解释一下树链剖分的思想和具体实现,同时添加一些自己的理解,来帮助理解这个实际上并不困难的算法. 树链剖分的基本思想树链剖分或许更应该被称作一种思想,就是将一棵树拆分成几个部分,使每个部分内的元素之间都具有一定的联系,从而允许我们对进行过剖分的树利用一些其他的高级数据结构进行一些难以暴力解决的操作,如: 将节点x到节点y的最短路径上的所有节点/边的权值加某个值 将以节点x为根的子树中的所有节点/边的权值加某个值 查询节点x到节点y的最短路径上的所有节点/边的权值之和 查询以节点x为根的子树中的所有节点/边的权值之和 (还可以顺便求最近公共祖先LCA) 也就是说,树链剖分就如同它的名字一样,就是将树解剖成若干个部分(称为树链),方便后续的操作. 前置知识需求在学习树链剖分之前,需要先行掌握如下的知识: 树的基本概念 图的基本概念 深度优先搜索(DFS) 线段树(或者树状数组) 基本概念为了完成分解,需要计算几个辅助数组的值.首先定义一些概念(在概念名后面的括号内的是数组名): 和普通树相同的概念(不详细解释了) 父节点(f) 子节点(head) 大小(size) 深度(dep) 额外添加的概念 重子节点(hson):节点的子节点中具有最大的size的一个(这类节点又称为重节点.特别的,根节点是重节点) 轻子节点:除重子节点以外的所有节点(这类节点又称为轻节点) 重边:连接父节点和重子节点的边 轻边:连接父节点和轻子节点的边(除重边的所有边) 重链:若干重边连接成的链(下文中也会称为树链) 轻链:若干轻边连接成的链 链顶(top):该节点所在的重链的顶端节点的序号(请注意,这里的序号与下文将出现的编号有所不同.序号是节点的原始编号,而编号的具体意义将在下文解释.) 为了确认自己是不是已经理解了这些概念,这里附上一张图,并给出某些数组在这种情况下的值.其中,重节点将在图中以红色标识,重边以粗线标识,轻边以细线标识. 表格似乎生成的有些问题,正在寻找解决方法,先用图片代替了. 值得注意的是,我们所有下标均从1开始,并以0表示不存在. 如果对于任意节点,我们在访问完后优先访问它的重子节点,并将所有节点按照访问顺序编号,将得到这样的一组编号: 仔细观察这两张图以及表格,能够发现如下性质: 两个节点x,y在同一条重链上,当且仅当top[x]==top[y] 任何一条重链上的点编号连续 以任何一个点为根的子树中的所有点编号连续 事实上,这就是树剖得以解决问题的根本.因此,我们引入了一个新值编号(id):从根节点开始,对于任意节点,先访问其重子节点,然后再访问其其他节点所得到的某节点的访问次序编号.正是id具有的连续性,使得我们能够用线段树完成一些操作. 如何使用树剖的结果在研究树剖的实现之前,先来看看在树剖完成后如何应用其结果.我们由简到繁的讨论如下几个应用: 将以节点x为根的子树中的所有节点/边的权值加某个值我们假设已经实现了一棵线段树,其名称为t(一下应用中均包含此假设). 关于线段树的具体实现请看完整代码或是我关于线段树的学习笔记(暂时还没有). 显然,由于以任何一个点为根的子树中的所有点编号连续,这时只需要对以x的编号为起始点,x子树中编号最大的节点的编号为终止点的区间进行区间修改,就可以完成这个操作了.而由于连续,最大的点的编号就是x编号加上x的大小.因此,修改的区间就是$[id[x],id[x]+size[x])$. 查询以节点x为根的子树中的所有节点/边的权值之和同理,只需要对区间进行区间求和就可以完成了,同样是线段树的基本操作.操作区间同样是$[id[x],id[x]+size[x])$. 求两个节点x和y的最近公共祖先(LCA)显然,两个节点之间的最短路径会经过两个节点的最近公共祖先.因此,在研究对两点间最短路径上的操作之前,我们先来看看如何用树链剖分得到的数据求LCA. 显然,如果两个节点在同一条树链上,它们的LCA就是两点中深度较小的节点.这时可以直接得到结果:LCA=dep[x]&gt;dep[y]?y:x.而当两个节点不在同一树链上时,我们就可以利用top迅速的向上跳跃,来到另一条树链上,尽快的使两个节点到达同一条树链上.这也就解释了为什么我们的原则是”对于任意节点,先访问其重子节点,然后再访问其其他节点”:size的大小可以在一定程度上反映这棵子树的高度,将高度最大的一条作为重链可以使这上面的点迅速跳到顶端,减少跳跃次数,提高算法的效率. 需要注意的是,我们应该让跳跃后到达的链顶深度更大的点跳跃而另一个点保持不动.这样才能保证两个点不会擦肩而过. 比如这个例子中,我们若要求点11和12的LCA,我们若首先让11向上跳跃将到达2,而事实上11和12的LCA是6,这时已经不可能再得到正确的结果了. 代码也不难写出: 123456789int lca(int x,int y) &#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=f[top[x]];//注意这里,top[x]和x仍在同一树链上,要到达另外一条树链需要取top[x]的父节点 &#125; return dep[x]&gt;dep[y]?y:x;&#125; 代码很简单,但是已经足够正确的求解LCA问题了. 将节点x到节点y的最短路径上的所有节点/边的权值加某个值我们采用和上面求LCA一样的思路:不断使两个节点向上移动从而逼近,直到两个节点到达同一树链,这时即可一步完成最后一段的操作. 不难想到,为了实现这个操作,我们只需要在每一步移动x点的时候,修改移动经过的点的权值,就可以轻松完成任务了.由于”任何一条重链上的点编号连续”,我们的区间也很好确定:两点在同一条树链上时,操作区间为$[min(id[x],id[y]),max(id[x],id[y])]$;每次移动x点的时候,操作区间为$[id[top[x]],id[x]]$(注意这里左边界不是$id[f[top[x]]]$,因为这个点将在下次被计算) 代码只需要在LCA代码的基础上稍加修改就可以了: 123456789101112void mod_path(int x,int y,int v)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); t.add(id[top[x]],id[x]+1,v);//由于个人习惯,我的线段树操作区间是左闭右开区间,因此+1 //实际的方法参数会更多,这里忽略了次要矛盾,只突出了主要矛盾:操作区间和增加的值 x=f[top[x]]; &#125; t.add(min(id[x],id[y]),max(id[x],id[y])+1,v); return;&#125; 同样是很简洁的代码,依然轻松的完成了任务. 查询节点x到节点y的最短路径上的所有节点/边的权值之和思路完全同上,只是将方法从修改变为区间求和,设置一个临时变量累加,最后返回. 注意:如果有要求千万不要忘记取余,否则请估计结果大小开足够大的变量避免溢出. 代码只需要简单修改上面的片段就可以了. 123456789101112int cal_path(int x,int y)&#123; int ans=0; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); ans+=t.cal(id[top[x]],id[x]+1); x=f[top[x]]; &#125; ans+=t.cal(min(id[x],id[y]),max(id[x],id[y])+1); return ans;&#125; 依旧简洁. 如何进行树剖现在,我们已经看到了树剖所得到的结果能够正确的工作,帮助我们高效的完成之前提到的几种操作.现在,是时候考虑如何计算这些辅助数组的值了.我们同样分为几步考虑. 输入/建树一般来讲,树的输入有两种:给出所有边的信息以及根节点的序号,或是给出根节点序号和f数组.无论对于哪一种情况,我们需要进行一次DFS.在这次DFS中,我们可以完成对f,size,dep,hson和head数组的初始化. 我们从根节点开始,对于每一个访问到的节点(记为t),标记t为已访问,将所有与其有边相连的未访问节点(记为to)的父节点设为t(若是第二种情况则可以省略这一步),并将to加入t的head集合中,更新to的dep的值,然后递归的以to为当前节点,继续操作,并在回溯时更新t的size和hson的值.下面是代码,更详细的解释将在代码中以注释的形式进行. 1234567891011121314151617181920212223void link_constructor(int t)&#123; a[t].size=1;//以当前节点为根的子树中目前只已知1个节点 visited[t]=1;//标记为已访问防止重复访问(死循环) //这里使用了链表,其细节将在下文出现 edge* tar=temp[t];//temp用于临时存储边(适用于第一种情况),在输入时完成初始化 while(tar!=NULL)//直到不再有与当前节点有边相连的节点为止 &#123; edge* tt=tar-&gt;next;//由于之后可能会修改tar指向的结构体中的next指针,预先存储其指向的地址 if(!visited[tar-&gt;to]) &#123; a[tar-&gt;to].f=t;//设置父节点 a[tar-&gt;to].dep=a[t].dep+1;//设置深度:比父节点深1层 link_constructor(tar-&gt;to);//递归调用,先完成子节点的构建,以便更新当前节点的值 if(a[t].hson==0 || a[a[t].hson].size&lt;a[tar-&gt;to].size) a[t].hson=tar-&gt;id;//若当前节点还没有重子节点或是重子节点不够重,进行更新 a[t].size+=a[tar-&gt;to].size;//更新当前节点的size,加上以子节点作为根的子树的size tar-&gt;next=a[t].head; a[t].head=tar;//将子节点加入集合 &#125; tar=tt;//查看下一个与当前节点有边相连的节点 &#125; return;&#125; 代码同样不长,现在,我们已经完成了f,size,dep,hson的计算,并删除了重边,完成了所有节点的子节点集合. 分割树虽然我们首先进行了一次DFS,但是不幸的是,由于不能预先确定重子节点,我们并不能在这一次DFS中确定重链,也不能给节点编号.因此我们再进行一次DFS.在这一次DFS中,我们就可以利用上一次DFS中得到的重子节点的数据给节点依照我们规定的原则编号,并确定重链,初始化每个节点的top值.同样,更详细的将在代码中说明. 12345678910111213141516171819202122int Index=0;//用于编号void split_constructor(int t)&#123; //有关初始化的细节将在下文出现 id[t]=++Index;//编号 if(hson[t])//如果有重子节点 &#123; top[hson[t]]=top[t];//显然重子节点和其父节点在同一条树链上,拥有共同的链顶 split_constructor(hson[t]);//优先访问重子节点 &#125; edge* tar=head[t]; while(tar!=NULL) &#123; if(tar-&gt;to!=hson[t])//注意不能重复访问节点 &#123; top[tar-&gt;to]=tar-to;//与父节点不在同一树链上,自己作为自己所在的树链的链顶 split_constructor(tar-&gt;to); &#125; tar=tar-&gt;next; &#125; return;&#125; 在这一次DFS中,我们按照之前确定的顺序,利用上一次DFS得到的信息,成功的将节点进行了编号,并且确定了各个节点的top值.这样就完成了对树的分割. 初始化线段树最终的操作要有线段树完成,因此还要完成对线段树的初始化.由于所有操作的区间均由节点的编号决定,因此用于构造线段树的数组的下标将与节点编号对应.我们采用一种简单而直观的方法完成(或许并不优美): 123456int tempval[MAX];//临时数组,MAX是最大节点数void sgtree_constructor(int n)//一共n个节点&#123; for(int i=1;i&lt;=n;i++) tempval[id[i]]=val[i];//将序号为i的节点的权值存储在临时数组下标为i的编号的位置 t.build(tempval,1,n+1);//调用线段树方法进行构造&#125; 这样,线段树也构造好了. 至此,各个部分均已完成,下面就只需要将这些部分串联在一起了. 总初始化函数只要按照逻辑,依次执行第一次DFS,第二次DFS,线段树初始化就可以了. 12345678910void constructor(int n,int r)&#123; f[r]=0;//根节点没有父节点 dep[r]=1;//根节点深度为1 link_constructor(r);//第一次DFS top[r]=r;//根节点是自己所在的树链的链顶 split_constructor(r);//第二次DFS sgtree_constructor(n);//初始化线段树 return;&#125; 至此,所有初始化已经完成,下面只需要正确的定义变量,正确的完成主函数的逻辑,按照要求处理输入的数据和指令并正确输出就可以了.下面,我们在实际问题中进行尝试. 例题P3178 [HAOI2015]树上操作事实上在洛谷是有树链剖分的模板题的,但是首先让我们从这个更简单一点的模板题开始吧(洛谷的模板题比这个要难).这道题是一个纯粹的树剖,没有任何技巧,甚至不需要进行两个点的向上移动操作(一股清流),纯粹是练习逻辑的.那么直接上就好了,像我这样写代码奇丑的人代码量都还算可以. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=100010;template&lt;typename T&gt;struct sgtree&#123; private: T tree[MAX&lt;&lt;2]; T change[MAX&lt;&lt;2]; void updata(int t) &#123; tree[t]=tree[t&lt;&lt;1]+tree[t&lt;&lt;1|1]; return; &#125; void pushdown(int t,int l,int r) &#123; if(!change[t]) return; int t1=t&lt;&lt;1; int t2=t&lt;&lt;1|1; int m=(l+r)&gt;&gt;1; tree[t1]+=change[t]*(m-l); tree[t2]+=change[t]*(r-m); change[t1]+=change[t]; change[t2]+=change[t]; change[t]=0; return; &#125; public: void build(T a[],int l,int r,int t) &#123; if(l==r-1) tree[t]=a[l]; else&#123; int m=(l+r)&gt;&gt;1; build(a,l,m,t&lt;&lt;1); build(a,m,r,t&lt;&lt;1|1); updata(t); &#125; return; &#125; void add(int t,int l,int r,int low,int high,T v) &#123; if(low&lt;=l &amp;&amp; r&lt;=high)&#123; tree[t]+=v*(r-l); change[t]+=v; &#125;else&#123; pushdown(t,l,r); int m=(l+r)&gt;&gt;1; if(low&lt;m) add(t&lt;&lt;1,l,m,low,high,v); if(m&lt;high) add(t&lt;&lt;1|1,m,r,low,high,v); updata(t); &#125; return; &#125; T cal(int t,int l,int r,int low,int high) &#123; if(low&lt;=l &amp;&amp; r&lt;=high) return tree[t]; pushdown(t,l,r); int m=(l+r)&gt;&gt;1; T ans=0; if(low&lt;m) ans+=cal(t&lt;&lt;1,l,m,low,high); if(m&lt;high) ans+=cal(t&lt;&lt;1|1,m,r,low,high); return ans; &#125;&#125;;sgtree&lt;long long&gt; sgt;struct edge&#123; int to; edge* next; edge() &#123; to=0; next=NULL; &#125;&#125;;edge e[MAX&lt;&lt;1];int n;long long val[MAX];long long tempval[MAX];int f[MAX];int top[MAX];int id[MAX];int dep[MAX];int hson[MAX];int size[MAX];bool visited[MAX];edge* temp[MAX];edge* head[MAX];int Index=0;int coun=0;void add_edge(int x,int y)&#123; e[coun].to=y; e[coun].next=temp[x]; temp[x]=&amp;e[coun++]; return;&#125;void tree_con(int t)&#123; visited[t]=1; size[t]=1; edge* tar=temp[t]; while(tar!=NULL) &#123; edge* n=tar-&gt;next; int&amp; to=tar-&gt;to; if(!visited[to]) &#123; f[to]=t; dep[to]=dep[t]+1; tree_con(to); if(!hson[t] || size[hson[t]]&lt;size[to]) hson[t]=to; size[t]+=size[to]; tar-&gt;next=head[t]; head[t]=tar; &#125; tar=n; &#125; return;&#125;void split_con(int t)&#123; id[t]=++Index; if(hson[t]) &#123; top[hson[t]]=top[t]; split_con(hson[t]); &#125; edge* tar=head[t]; while(tar!=NULL) &#123; int&amp; to=tar-&gt;to; if(to!=hson[t]) &#123; top[to]=to; split_con(to); &#125; tar=tar-&gt;next; &#125; return;&#125;void sgtree_con(void)&#123; for(int i=1;i&lt;=n;i++) tempval[id[i]]=val[i]; sgt.build(tempval,1,n+1,1); return;&#125;void constructor(int r)&#123; tree_con(r); top[r]=r; split_con(r); sgtree_con(); return;&#125;long long cal_path(int x)&#123; long long ans=0; while(top[x]!=1) &#123; ans+=sgt.cal(1,1,n+1,id[top[x]],id[x]+1); x=f[top[x]]; &#125; ans+=sgt.cal(1,1,n+1,1,id[x]+1); return ans;&#125;int main()&#123; int m,x,y,flag; long long a; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld",val+i); for(int i=1;i&lt;n;i++) &#123; scanf("%d%d",&amp;x,&amp;y); add_edge(x,y); add_edge(y,x); &#125; constructor(1); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;flag,&amp;x); if(flag==1)&#123; scanf("%lld",&amp;a); sgt.add(1,1,n+1,id[x],id[x]+1,a); &#125;else if(flag==2)&#123; scanf("%lld",&amp;a); sgt.add(1,1,n+1,id[x],id[x]+size[x],a); &#125;else if(flag==3)&#123; printf("%lld\n",cal_path(x)); &#125; &#125; return 0;&#125; P3379 【模板】最近公共祖先（LCA）是的,是时候报复这道题了!之前能卡我的常数,看看这回用新的方法它还能不能卡住我! 这同样是树链剖分的删减版,虽然需要进行两点上移的操作,但是由于不需要计算权值,我们不需要构造线段树,也不需要为节点编号,只需要正确的top数组就可以AC这道题.因此,代码同样不长(虽然不长,但看起来依然很丑). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=500010;struct edge&#123; int to; edge* next; edge() &#123; to=0; next=NULL; &#125;&#125;;edge e[MAX&lt;&lt;1];edge* temp[MAX];edge* head[MAX];int f[MAX];int next[MAX];int size[MAX];int dep[MAX];int top[MAX];int id[MAX];bool visited[MAX];int ecount=0;void dfs(int t)&#123; size[t]=1; next[t]=0; edge* tar=temp[t]; while(tar!=NULL) &#123; edge* nn=tar-&gt;next; if(!visited[tar-&gt;to]) &#123; dep[tar-&gt;to]=dep[t]+1; visited[tar-&gt;to]=1; f[tar-&gt;to]=t; dfs(tar-&gt;to); size[t]+=size[tar-&gt;to]; if(!next[t] || size[next[t]]&lt;size[tar-&gt;to]) next[t]=tar-&gt;to; tar-&gt;next=head[t]; head[t]=tar; &#125; tar=nn; &#125; return;&#125;void split(int t)&#123; if(next[t]!=0) &#123; id[next[t]]=++ecount; top[next[t]]=top[t]; split(next[t]); &#125; edge* tar=head[t]; while(tar!=NULL) &#123; if(tar-&gt;to!=next[t]) &#123; id[tar-&gt;to]=++ecount; top[tar-&gt;to]=tar-&gt;to; split(tar-&gt;to); &#125; tar=tar-&gt;next; &#125; return;&#125;void build_tree(int s)&#123; dep[s]=1; visited[s]=1; f[s]=0; dfs(s); return;&#125;void init_split(int s)&#123; id[s]=0; top[s]=s; split(s);&#125;void total_init(int s)&#123; build_tree(s); init_split(s); return;&#125;int lca(int a,int b)&#123; while(top[a]!=top[b]) &#123; if(dep[top[a]]&lt;dep[top[b]]) swap(a,b); a=f[top[a]]; &#125; return dep[a]&gt;dep[b]?b:a;&#125;int main()&#123; int n,x,y,s,m; scanf("%d%d%d",&amp;n,&amp;m,&amp;s); for(int i=0;i&lt;n-1;i++) &#123; scanf("%d%d",&amp;x,&amp;y); e[i&lt;&lt;1].to=y; e[i&lt;&lt;1].next=temp[x]; temp[x]=&amp;e[i&lt;&lt;1]; e[i&lt;&lt;1|1].to=x; e[i&lt;&lt;1|1].next=temp[y]; temp[y]=&amp;e[i&lt;&lt;1|1]; &#125; total_init(s); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",lca(x,y)); &#125; return 0;&#125; 这样就不会再被这道题卡常数了(虽然和没有使用vector有关,但实际上这种方法依然比使用了同样存储方式的倍增快近300ms). P3384 【模板】树链剖分终于来到了这里.我们已经在之前的两道例题中分别测试了树剖算法的一部分功能,而现在我们要将所有功能组合在一起,用完整版的树剖A掉这道题(“A上去就赢啦!”). 其实依然很简单,只要将所有功能放进去,写好主函数就已经成功了.(因为代码量变大了,所以代码更丑了) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=100010;int count_edge=0;int Index=0;int n,pp;bool visited[MAX];template&lt;typename T&gt;struct sgtree&#123; private: T tree[MAX&lt;&lt;2]; T change[MAX&lt;&lt;2]; T p; void updata(int t) &#123; tree[t]=(tree[t&lt;&lt;1]+tree[t&lt;&lt;1|1])%p; return; &#125; void pushdown(int t,int l,int r) &#123; if(!change[t]) return; int t1=t&lt;&lt;1; int t2=t&lt;&lt;1|1; int m=(l+r)&gt;&gt;1; tree[t1]=(tree[t1]+change[t]*(m-l))%p; tree[t2]=(tree[t2]+change[t]*(r-m))%p; change[t1]=(change[t1]+change[t])%p; change[t2]=(change[t2]+change[t])%p; change[t]=0; return; &#125; public: void init(T mo) &#123; p=mo; return; &#125; void build(T a[],int l,int r,int t) &#123; if(l==r-1) tree[t]=a[l]%p; else&#123; int m=(l+r)&gt;&gt;1; build(a,l,m,t&lt;&lt;1); build(a,m,r,t&lt;&lt;1|1); updata(t); &#125; return; &#125; void add(int t,int l,int r,int low,int high,T v) &#123; if(low&lt;=l &amp;&amp; r&lt;=high)&#123; tree[t]=(tree[t]+v*(r-l))%p; change[t]=(change[t]+v)%p; &#125;else&#123; pushdown(t,l,r); int m=(l+r)&gt;&gt;1; if(low&lt;m) add(t&lt;&lt;1,l,m,low,high,v); if(m&lt;high) add(t&lt;&lt;1|1,m,r,low,high,v); updata(t); &#125; return; &#125; T cal(int t,int l,int r,int low,int high) &#123; if(low&lt;=l &amp;&amp; r&lt;=high) return tree[t]%p; pushdown(t,l,r); int m=(l+r)&gt;&gt;1; T ans=0; if(low&lt;m) ans+=cal(t&lt;&lt;1,l,m,low,high); if(m&lt;high) ans+=cal(t&lt;&lt;1|1,m,r,low,high); return ans; &#125;&#125;;sgtree&lt;int&gt; sgt;struct edge&#123; int id; edge* next; edge() &#123; id=0; next=NULL; &#125;&#125;e[MAX&lt;&lt;1];edge* temp[MAX];struct node&#123; int id; int f; int hson; int val; int top; int dep; int size; edge* head; node() &#123; id=0; f=0; hson=0; val=0; top=0; dep=0; size=0; head=NULL; &#125;&#125;a[MAX];int tempval[MAX];void link_constructor(int t)&#123; a[t].size=1; visited[t]=1; edge* tar=temp[t]; while(tar!=NULL) &#123; edge* tt=tar-&gt;next; if(!visited[tar-&gt;id]) &#123; a[tar-&gt;id].f=t; a[tar-&gt;id].dep=a[t].dep+1; link_constructor(tar-&gt;id); if(a[t].hson==0 || a[a[t].hson].size&lt;a[tar-&gt;id].size) a[t].hson=tar-&gt;id; a[t].size+=a[tar-&gt;id].size; tar-&gt;next=a[t].head; a[t].head=tar; &#125; tar=tt; &#125; return;&#125;void split_constructor(int t)&#123; a[t].id=++Index; if(a[t].hson) &#123; a[a[t].hson].top=a[t].top; split_constructor(a[t].hson); &#125; edge* tar=a[t].head; while(tar!=NULL) &#123; if(tar-&gt;id!=a[t].hson) &#123; a[tar-&gt;id].top=tar-&gt;id; split_constructor(tar-&gt;id); &#125; tar=tar-&gt;next; &#125; return;&#125;void sgtree_constructor(int p)&#123; sgt.init(p); for(int i=1;i&lt;=n;i++) tempval[a[i].id]=a[i].val; sgt.build(tempval,1,n+1,1); return;&#125;void major_constructor(int r,int p)&#123; a[r].dep=1; link_constructor(r); a[r].top=r; split_constructor(r); sgtree_constructor(p); return;&#125;void mod_xtoy(int x,int y,int v)&#123; while(a[x].top!=a[y].top) &#123; if(a[a[x].top].dep&lt;a[a[y].top].dep) swap(x,y); sgt.add(1,1,n+1,a[a[x].top].id,a[x].id+1,v); x=a[a[x].top].f; &#125; sgt.add(1,1,n+1,min(a[x].id,a[y].id),max(a[x].id,a[y].id)+1,v); return;&#125;int cal_xtoy(int x,int y)&#123; int ans=0; while(a[x].top!=a[y].top) &#123; if(a[a[x].top].dep&lt;a[a[y].top].dep) swap(x,y); ans=(ans+sgt.cal(1,1,n+1,a[a[x].top].id,a[x].id+1))%pp; x=a[a[x].top].f; &#125; ans=(ans+sgt.cal(1,1,n+1,min(a[x].id,a[y].id),max(a[x].id,a[y].id)+1))%pp; return ans;&#125;int main()&#123; int m,r,x,y; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;r,&amp;pp); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].val); for(int i=1;i&lt;n;i++) &#123; scanf("%d%d",&amp;x,&amp;y); e[count_edge].id=y; e[count_edge].next=temp[x]; temp[x]=&amp;e[count_edge++]; e[count_edge].id=x; e[count_edge].next=temp[y]; temp[y]=&amp;e[count_edge++]; &#125; major_constructor(r,pp); int flag,z; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;flag,&amp;x); if(flag==4) printf("%d\n",sgt.cal(1,1,n+1,a[x].id,a[x].id+a[x].size)%pp); else if(flag==3)&#123; scanf("%d",&amp;z); sgt.add(1,1,n+1,a[x].id,a[x].id+a[x].size,z); &#125;else if(flag==2)&#123; scanf("%d",&amp;y); printf("%d\n",cal_xtoy(x,y)%pp); &#125;else&#123; scanf("%d%d",&amp;y,&amp;z); mod_xtoy(x,y,z); &#125; &#125; return 0;&#125; A掉了这道题,就可以说是掌握了树剖的一些皮毛了.下面,再去洛谷寻找带有树链剖分标签的题,开始虐题(被题虐)吧. 后记其实树链剖分本身并没有很难.它的逻辑很清晰,过程也极其简单:DFS1,DFS2,再写好线段树,基本就完成了.而难的地方是它衍生出来的花样.如果能够正确的看出来哪里可以用树剖解决,剩下的问题就好解决了. 我是一棵蒟蒻,如果有幸有大犇路过发现我哪里理解的不对,出现了偏差,还请大犇使劲的喷,那也是对我的帮助.谢谢.]]></content>
      <tags>
        <tag>树</tag>
        <tag>树算法</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈并查集]]></title>
    <url>%2F2018%2F03%2F25%2F%E6%B5%85%E8%B0%88%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[最近在洛谷上看到了一道水题,是NOI2002的第一题,银河英雄传说.一看上去就是个并查集,感觉很简单的样子(心想:没想到NOI还有这么水的题!),结果一做才知道:逻辑想的挺好,实际上就是WA.在交了好几次WA之后,仔细把自己的逻辑重新整理了几遍,终于发现了问题所在,于是A掉了这道题.(明明我的逻辑基本上一点问题都没有,就是忽略了一个赋值的先后带来的影响!) 感觉自己还是没有真正掌握并查集的皮毛(好伤心),于是打算总结一下并查集,争取能温故知新. 并查集的意义(需求)标准的并查集是为了高效的进行一系列的如下操作: 将x和y所在的集合合并为一个集合 查询x与y是否存在于同一集合 其中由于是集合的合并,因此我们需要重新将集合中的所有元素放入新的集合.而并查集就是为了高效的实现这些操作. 并查集的基本思想我们采用一个标记值,具有相同的标记值的元素将被认为是存在于同一集合中.理论上这个标记值是任意的,但为了方便,我们常常将集合中的某个元素作为标记值. 前置知识需求为了理解并查集,需要现行学习以下的知识: 数组的基本操作 树的基本概念 递归算法 结构体 链表 并查集的初级实现并查集的数组实现显然,可以用一个一位数组(称之为f)完成所需要进行的操作.元素x与y在同一个集合当且仅当f[x]==f[y].代码很简单. 1234567891011121314151617181920const int MAX=10010;int f[MAX];int n;//假设n中已经存储了当前的总元素数void init(void)//初始化&#123; for(int i=1;i&lt;=n;i++) f[i]=i;//开始任何两个元素都不在同一集合中 return;&#125;void join(int x,int y)//合并&#123; if(f[x]==f[y]) return;//不必检查已经合并的,可以节省一定的时间(没啥用) int tmp=f[x]; for(int i=1;i&lt;=n;i++) if(f[i]==tmp) f[i]=f[y];//调整所有的与x在同一集合中的元素的标记值使其与y中元素的标记值相同,从而表示它们被合并进了进入y所在的集合 return;&#125;bool check(int x,int y)//检查x与y是否在同一个集合中&#123; return f[x]==f[y];&#125; 显然,这个方法是正确的.我们可以尝试通过洛谷的并查集模板题(记得看清数组要开多大).完整的代码像下面这样(如同以前一样,我会省略一切之前出现过的解释文字): 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;using namespace std;const int MAX=10010;int f[MAX];int n;void init(void)&#123; for(int i=1;i&lt;=n;i++) f[i]=i; return;&#125;void join(int x,int y)&#123; if(f[x]==f[y]) return; int tmp=f[x]; for(int i=1;i&lt;=n;i++) if(f[i]==tmp) f[i]=f[y]; return;&#125;bool check(int x,int y)&#123; return f[x]==f[y];&#125;int main()&#123; int m,flag,x,y; scanf("%d%d",&amp;n,&amp;m); init(); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;flag,&amp;x,&amp;y); if(flag==1) join(x,y); else if(check(x,y)) printf("Y\n"); else printf("N\n"); &#125; return 0;&#125; umm…AC了(和我的计划有些出入).好吧,我们来这里进行尝试:259. 亲戚. 仔细读题,发现这也是一个单纯的并查集.因此,按照题目的输入格式修改一下代码(请注意,这里使用的是文件读写),比赛中是没有优化的,因此我们选择 “无优化开关”(一定要选…不然…). umm…TLE了(强行). 我们来胡乱分析一波时间复杂度.对于n个元素m次操作,假设合并和查询随机出现,而合并时间复杂度为$O(n)$,查询为$O(1)$,平均时间复杂度近似为$O(nm)$,显然太慢,因此会超时. 我们来思考另一种思路:之前的方法中时间主要浪费在合并时遍历f数组.我们想到使用链表,将同一集合的元素链在一起,那么我们修改时只需要遍历一遍其中一条链,再将两条链拼接在一起,而不会访问无意义的数据,显然提高了效率.按照这个思路,我们获得了并查集的另一种初级实现. 并查集的链表实现我们定义一个结构体,将元素的信息存储进去,然后定义一个结构体数组表示元素,命名为a,像这样: 123456789101112131415const int MAX=10010;struct ele&#123; ele* f;//指向下标为当前元素的标记值的元素的指针 ele* next;//指向链表中下一个元素的指针 ele* ends;//指向链表末尾的指针 ele()//构造函数,用于初始化 &#123; f=this;//各自为一个集合,自己的下标就是自己的标记值 next=NULL;//链表只有当前一个元素,没有下一个元素 ends=this;//链表末尾就是自己 &#125;&#125;;ele a[MAX]; 我们在检查x和y是否在同一个集合中的时候,同样仅需检查它们的f是否相同,也就是x与y在同一集合,当且仅当a[x].f==a[y].f.写成函数: 1234bool check(int x,int y)&#123; return a[x].f==a[y].f;&#125; 而合并时,我们需要遍历一遍其中一条链(链x),修改其上的所有元素的f.为了方便和直观起见,我们选用链表头元素的下标作为标记值.那么,我们就只需要在遍历并修改f之后,修改另一条链(链y)的尾的next值使其指向链x,那么链x就被连接到了链y之后,依然满足我们的约定.代码: 123456789101112void join(int x,int y)&#123; if(check(x,y)) return;//已经在同一集合中,不必合并 ele* tar=a[x].f;//当前元素 ele* head=tar;//保存原链的头(其实修改一下下面的代码就可以省下这一个空间,但我懒得改了) while(tar!=NULL)//直到移出了链表 &#123; tar-&gt;f=a[y].f;//修改f值 tar=tar-&gt;next;//向后移动 &#125; a[y].f-&gt;ends-&gt;next=head;//将两条链连接&#125; 这样就完成了并查集的链表实现.我们再次尝试去解决259. 亲戚.完善之后的完整代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;using namespace std;const int MAX=20010;struct ele&#123; ele* f; ele* next; ele* ends; ele() &#123; f=this; next=NULL; ends=this; &#125;&#125;;ele a[MAX];bool check(int x,int y)&#123; return a[x].f==a[y].f;&#125;void join(int x,int y)&#123; if(check(x,y)) return; ele* tar=a[x].f; ele* head=tar; while(tar!=NULL) &#123; tar-&gt;f=a[y].f; tar=tar-&gt;next; &#125; a[y].f-&gt;ends-&gt;next=head;&#125;int main()&#123; freopen("relations.in","r",stdin);//文件读 freopen("relations.out","w",stdout);//文件写 int n,m,x,y,q; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); join(x,y); &#125; scanf("%d",&amp;q); for(int i=1;i&lt;=q;i++) &#123; scanf("%d%d",&amp;x,&amp;y); if(check(x,y)) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; 依然选择无优化开关,这次成功的A掉了这道题. 但是仔细观察数据,我们注意到有好几个点是900多毫秒通过的,在超时的边缘试探.看来还是不行.我们再来分析. 这个方法中的时间主要仍是遍历一遍链表.我们注意到虽然操作两条链表,但需要遍历的只有一条.自然想到,我们应该尽量的去遍历更短的那一条,这样会花费更少的时间.如何确定那一条更短呢?我们可以在结构体中添加一个变量size,表示以该元素为表头的链表的长度.显然,合并将使链表的长度变为两链原长之和,而我们只须修改表头元素的信息即可,不会花费过多的额外时间.而初始化也很简单:只有一个元素的链表长度自然为1. 而在合并时,我们只需要判断一下,选择遍历更短的链表即可.修改后的代码只加上了为数不多的几条语句: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;using namespace std;const int MAX=20010;struct ele&#123; ele* f; ele* next; ele* ends; int size;//定义size ele() &#123; f=this; next=NULL; ends=this; size=1;//初始化size &#125;&#125;;ele a[MAX];bool check(int x,int y)&#123; return a[x].f==a[y].f;&#125;void join(int x,int y)&#123; if(check(x,y)) return; if(a[x].f-&gt;size&gt;a[y].f-&gt;size) x^=y^=x^=y;//如果x链的长度更长,交换x和y的值,使得这行执行后x所在的链是更短的链 ele* tar=a[x].f; ele* head=tar; while(tar!=NULL) &#123; tar-&gt;f=a[y].f; tar=tar-&gt;next; &#125; a[y].f-&gt;ends-&gt;next=head; a[y].f-&gt;size+=head-&gt;size;//维护size的值&#125;int main()&#123; freopen("relations.in","r",stdin); freopen("relations.out","w",stdout); int n,m,x,y,q; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); join(x,y); &#125; scanf("%d",&amp;q); for(int i=1;i&lt;=q;i++) &#123; scanf("%d%d",&amp;x,&amp;y); if(check(x,y)) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; 再次尝试提交,在无优化开关的情况下,我们的优化成功使耗时最长的测试点从$912ms$优化到了$53ms$,而代码量只增加了4行,内存占用增加了$20kb$. 似乎到这里已经很优了.但事实上,我们还能做的更好.放松对于属于同一集合的元素标记值的限制,将给我们打开更广阔的空间.在下面的方法中,我们将不再限定属于同一集合的元素必须被相同的标记值标记.这将使我们的查找变慢,但将提高合并速度. 并查集的有根树实现现在我们重新定义一下我们的f数组: f[i]表示元素i在树上父亲是f[i]. 特殊的,对于没有父亲的节点(如x),我们令f[x]=x,并称这样的元素为其子树中任意元素的祖先. 现在,对于两个元素x和y,它们在同一集合中当且仅当x的祖先和y的祖先相同. 按照这些定义和约定,我们分不同的操作来看如何用这种方式实现并查集. 1.如何使用 同样的,在研究如何初始化(并操作)并查集之前,我们先假设已经完成了这些操作,来研究如何正确的进行查询. 假设我们现在被询问元素x与y是否存在于同一个集合中.按照我们之前给出的定义,我们应该分别寻找x和y的祖先,然后比较这两个祖先是否相同.而祖先(设为k)的标志是f[k]==k,那么我们就可以用一个while循环完成对祖先的查找;由于一次check中要进行两次查询,我们将查询写为函数可以减小代码量.按照我们的分析,可以写出如下的代码: 12345678910//略去了对数组的定义int find(int a)//寻找a的祖先&#123; while(f[a]!=a) a=f[a];//当f[a]!=a时,说明当前的a尚不是祖先,我们要继续向上寻找 return a;//此时一定有a==f[a],也就是说我们已经找到了祖先,就是当前的a,直接返回&#125;bool check(int x,int y)&#123; return find(x)==find(y);//将find写为函数之后check函数就无比简单了,直接比较以x和y为参数执行的find返回的祖先是否相同就可以了&#125; 可以像这样形象(但不一定准确)的理解这个过程:这是一个组织,有准确的领导关系:每个人会被另一个人领导(他的父亲),但同时他可以领导多个其他人(当然,也肯能只领导一个人或是谁也不领导).其中只有一个例外:有一个老大(祖先),他是老大,他说了算,我们可以认为是他领导自己.因此,f[r]==r(r表示根,祖先,这里的老大).现在这里有很多这样的组织. 有一天有两个人碰面了,他们想知道他们是不是在一个组织中,怎么办?只要看看他们是不是受同一个老大领导就好了. 于是两个人就分别去问他们的领导,咱们老大是谁啊?如果他们的领导不是自己领导自己,那么他就不是老大.那就让领导去问领导的领导,直到问到一个人,他自己领导自己,那么他就是老大.他告诉来问自己的人:我就是老大!于是那个人知道了,再回去告诉来问自己的人:xxx就是老大.于是就这样一路传达,直到最初提问的那个人,于是他就知道了自己的老大就是xxx. 两个人都知道了自己的老大是谁,那么只要看看老大是不是一个人就知道了. 2.如何完成合并 现在假设我们被要求将x所在的集合和y所在的集合合并为一个集合.这也就意味着x所在集合中的任何元素的祖先必须被设定为与y中元素的祖先相同(反过来也可以).显然,如果逐个修改和朴素方法是没有区别的,我们考虑一个牵一发而动全身的方法:只要将x所在集合的祖先的父亲设为y所在集合的祖先,那么我们查询时的循环将不会在x的原祖先处停止,而会查询到y的祖先,而原y所在集合中的元素的祖先不会发生变化. 这样,我们在合并时不再需要遍历,只需要找到两个集合的祖先并且使其中一个(k)成为另一个(l)的父亲,那k就成为了原来k和l的子树中的所有元素的共同祖先,而这只会让我们在查询时增加不超过1次.而我们发现这里又出现了寻找祖先的工作,同样交给我们的find函数. 按照我们的分析,代码同样不难写出: 123456789//省略掉find函数void join(int x,int y)&#123; int fx=find(x); int fy=find(y); if(fx==fy) return;//不进行无意义的合并 f[fx]=fy;//反过来,f[fy]=fx也可以,看个人喜好 return;&#125; 继续按上文的例子理解一下:现在x和y所在的组织被要求合并成一个组织了.怎么办?我们只能让其中的一个老大屈尊,被另一个老大领导,那么就成为一个组织了. 3.如何初始化 这是最简单的一步了.一开始任意两个元素都不在同一个集合中,那么各自都是自己的祖先(-_-||),只要让f[i]=i就可以了. 123456//省略n的定义并假设n中存储了总元素的量void init(void)&#123; for(int i=1;i&lt;=n;i++) f[i]=i; return;&#125; umm…各自为战,我一个人就是一个组织… 将之前的三部分中的所有函数组合在一起,定义数组f和变量n,我们就完成了并查集的初级实现,已经能正确的完成前面提到的操作了!为了美观和方便,我们将并查集写成一个结构体,将数组作为成员变量,并用private关键字保护,函数作为方法出现(由于没有直接查询祖先的需求,find函数将同样被加以保护): 12345678910111213141516171819202122232425262728293031323334const int MAX=10010;int n;struct uf&#123; private://一般不能从结构体以外访问到 int f[MAX]; int find(int a) &#123; while(f[a]!=a) a=f[a]; return a; &#125; public://允许从结构体外访问 void init(void) &#123; for(int i=1;i&lt;=n;i++) f[i]=i; return; &#125; bool check(int x,int y) &#123; return find(x)==find(y); &#125; void join(int x,int y) &#123; int fx=find(x); int fy=find(y); if(fx==fy) return; f[fx]=fy; return; &#125;&#125;; 完成了.可以正确的书写主函数,再去水一次259. 亲戚. 像这样: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;using namespace std;const int MAX=20010;int n;struct uf&#123; private: int f[MAX]; int find(int a) &#123; while(f[a]!=a) a=f[a]; return a; &#125; public: void init(void) &#123; for(int i=1;i&lt;=n;i++) f[i]=i; return; &#125; bool check(int x,int y) &#123; return find(x)==find(y); &#125; void join(int x,int y) &#123; int fx=find(x); int fy=find(y); if(fx==fy) return; f[fx]=fy; return; &#125;&#125;;uf f;int main()&#123; freopen("relations.in","r",stdin); freopen("relations.out","w",stdout); int m,x,y,q; scanf("%d%d",&amp;n,&amp;m); f.init(); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); f.join(x,y); &#125; scanf("%d",&amp;q); for(int i=1;i&lt;=q;i++) &#123; scanf("%d%d",&amp;x,&amp;y); if(f.check(x,y)) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; ummm…TLE…似乎受到欺骗,不是说我们能做的更好了吗? 没错,所以我们这是基本实现. 胡乱分析一下,显然存在一些特定的数据可以使我们的树变得很丑:长的像一条链.那么我们的运行速度就变得比未优化的链表的速度还慢:链表只需要遍历其中一条,而我们需要遍历两条.下面,我们将针对这种情况进行优化,我们可以看到如何用简洁的几条语句完成优化,甚至使我们的查询和合并的时间复杂度同时被优化到近似为$O(1)$. 高效并查集的实现相比并查集的初级实现,我们考虑从两个思路上出发进行优化,一个是之前使用过的,通过维护额外信息使得每次合并遍历尽量少的点,另一个则是之前没出现但同样直观的. 带权合并显然,由于每次find都需要找到祖先才会停止,而每次find运行时间正比于其进行循环的次数,而循环次数又取决于树的高度.因此,我们可以维护一个高度值.同样,我们规定一个元素所存储的高度是以这个元素为祖先的树的高度. 合并时有两种情况:当两棵树高度不同时,我们选择将矮一些的树合并进高一些的树,其总高度不会发生变化(由于合并时将一棵树的根作为另一棵树的根的父亲,被合并进来的树中的节点到根的距离将全部加1,因此选择将更矮的树和并进更高的树,这样访问这棵树,寻找祖先时最多寻找的次数不会发生改变,也就是总高度不变);而当两棵树高度相同时,可以任意合并,但其高度会增加1. 和链表实现的优化一样,这个优化同样只需要为数不多的语句: 1234567891011121314151617181920212223242526272829303132333435363738394041const int MAX=20010;int n;struct uf&#123; private: int f[MAX]; int h[MAX];//新定义一个额外信息的数组 int find(int a) &#123; while(f[a]!=a) a=f[a]; return a; &#125; public: void init(void) &#123; for(int i=1;i&lt;=n;i++) &#123; f[i]=i; h[i]=1;//初始化高度为1 &#125; return; &#125; bool check(int x,int y) &#123; return find(x)==find(y); &#125; void join(int x,int y) &#123; int fx=find(x); int fy=find(y); if(fx==fy) return; if(h[fx]&gt;h[fy]) fx^=fy^=fx^=fy;//保证h[fx]&lt;=h[fy] f[fx]=fy; if(h[fx]==h[fy]) h[fy]++;//如果两棵树高度相同那么合并后高度会增加1 return; &#125;&#125;; 再次尝试259. 亲戚.(由于主函数没有修改,不再给出主函数的代码) 我们又A掉了这道题.花费的时间和带优化的链表实现近似. 路径压缩我们考虑我们这种表示的最优情况:我们当然希望任何的元素都的父亲都直接就是它的祖先.这似乎很难,但我们考虑一下,是否可以在查找的过程中完成这个操作. 在查找时,我们会一路查找到祖先.那么,我们是否可能在找到祖先后将沿途经过的节点的父亲都设为找到的祖先?不难想到这么一个东西:递归. 接着用那些迷之组织来描述这一个过程.由于之前的方法找老大要经过他的手下,太麻烦了,老大希望精简管理层:所有人都由他直接领导.怎么办呢?他要求来询问自己(root)老大是谁的人(mid)在回答mid的手下(leaf)的时候,告诉leaf:以后我就不是你的领导了,我的领导以后就是你的领导了.这样,一次询问后,经过的所有人的领导就都变成了老大.計画通り. 按照这个过程,运用递归,代码很好写,只用修改find方法就行了: 12345int find(int a)&#123; if(f[a]!=a) return f[a]=find(f[a]);//当前的被询问的人不是老大,那么让他的领导再去询问,并在得知老大是谁后将自己的领导更改为原来的领导的领导(模拟一下其实就是老大) return a;//"我就是老大"&#125; 还是两行,但运用递归完成了路径的压缩.现在,只要一个节点被查询过一遍,那么在下次合并之前,就可以在$O(1)$的时间内找到它的祖先. 我们再去虐一下这道题. 同样A掉,时间和带权合并近似. 应用两种优化我们再来尝试一下同时应用两种优化.大概比只用一种优化快了$2ms$. 实践证明,一般来说只要应用一种优化就足够了.其中路径压缩代码量极小,一半推荐使用,而带权合并可以提供额外信息,更适合要求回答或是进行其他操作时需要额外信息的情况使用.(当然,代码量也不大,我倾向于都用). 完整代码如下(只有结构体的): 123456789101112131415161718192021222324252627282930313233343536373839struct uf&#123; private: int f[MAX]; int h[MAX]; int find(int a) &#123; if(f[a]!=a) return f[a]=find(f[a]); return a; &#125; public: void init(int n)//为了增强泛用性,体现数据隐藏的严谨性,我们将n作为参数传入而不是使用全局变量 &#123; for(int i=1;i&lt;=n;i++) &#123; f[i]=i; h[i]=1; &#125; return; &#125; bool check(int x,int y) &#123; return find(x)==find(y); &#125; void join(int x,int y) &#123; int fx=find(x); int fy=find(y); if(fx==fy) return; if(h[fx]&gt;h[fy]) fx^=fy^=fx^=fy; f[fx]=fy; if(h[fx]==h[fy]) h[fy]++; return; &#125;&#125;; 至此,这样一种高效的数据结构的皮毛就已经基本被掌握了.我很喜欢这个数据结构,因为它强大高效但是代码量很小(而且不会写的太丑对于我来说简直就是福音w). 例题 1.裸并查集 由于这些题目都是最基本的,没花样的并查集应用,一套代码就可以水个遍,就没有代码了. 259. 亲戚 P3367 【模板】并查集 P1551 亲戚 2.花样题 这里的题很有意思,可能不是简单的并查集,需要思考和分析.(但请相信,这些题不需要其他的数据结构).题解会有,但是可能是有生之年,还是去看看别人的吧. P1525 关押罪犯 P1196 [NOI2002]银河英雄传说 umm暂时就这些了. 后记简单的并查集是很简单的.而经过一些技巧性的操作,它可以很强大.但是它最大的特点仍是代码量极小而高效(即使是加上了技巧性的操作). 更高级的操作?可持久化?ummm…还没研究,大概是有生之年了. 请路过的大犇如果发现了我文中的错误或是不严谨的地方一定在评论中告诉我,感激不尽. 本蒟蒻在此鞠躬.]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡树之Treap]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%B9%B3%E8%A1%A1%E6%A0%91%E4%B9%8BTreap%2F</url>
    <content type="text"><![CDATA[Treap,很奇怪的名字.但是如果能拆成Tree+heap,那么就好理解了:既是树(二叉搜索树),又是堆(最大最小随意,本文中将使用最小堆). Treap是非常暴力的一种平衡树实现,它利用一个随机值,在按照二叉搜索树的规则插入元素之后再(如果必要)通过旋转维持堆的性质,提供不确定的变形机会,避免出现树高为$O(n)$的最坏情况.事实上,Treap的期望高度为$O(log\;n)$.因为暴力,所以其并不能保证绝不会出现最坏的情况,但出现最坏情况的几率极小(据说甚至远小于电脑被闪电击中的几率?),而且实现简单,因此很好用. 需要注意的是,数据遵守的是二叉搜索树的规则,而随机权值遵守的是堆的规则. 前置知识 二叉搜索树 递归 引用 结构定义由于链式结构看起来太复杂,而且应用引用可以大大的简化代码,我们不定义结构体,而是使用一系列数组.定义如下: 123456789const int MAX=10010; //数据范围来自洛谷上的普通平衡树,连接下面有int rear=1; //下一个新开节点的下标int val[MAX]; //节点存储的值int w[MAX];int cnt[MAX]; //节点存储的值重复的次数int size[MAX]; //以节点为根的子树规模(总值数量,包括重复)int lt[MAX]; //节点的左孩子int rt[MAX]; //节点的右孩子//特殊的,我们令lt[0]指向根节点(其实没必要),有效的节点下标不为0 很明显,我们在结构中定义了一般的平衡树不必须的数据size.事实上,我们会维护这个数据以进行数据的”排名”的统计和查找特定排名的元素. 在这里,代码实现的功能以及一些细节取决于洛谷上的P3369 【模板】普通平衡树（Treap/SBT）. Treap的各种操作基本操作首先,我们需要多次更新节点的size值.我们定义一个函数来简化代码.函数接受一个指向节点的指针作为参数,按照其左右子树(如果存在)的信息更新自身的size值,无返回值.为了提高效率,函数将被定义为内联函数.函数假设传入的指针不指向NULL. 1234567inline void updata(const int&amp; k)&#123; size[k]=cnt[k]; if(lt[k]) size[k]+=size[lt[k]]; if(rt[k]) size[k]+=size[rt[k]]; return;&#125; 不难看出,由于没有改变任何树的结构,updata操作不会导致Treap的性质遭到破坏. 为了保持堆的特性同时不影响搜索树的性质,我们再定义一种操作:旋转.旋转分为左旋转和右旋转,具体操作如图: 这一对操作是对称的.对照图示,代码不难写出.代码中,我们传入指向上方节点的下标指针的引用来简化代码.函数同样定义为内联函数.在左,右旋转函数中,我们分别假设参数所指向的节点的右,左孩子不为空(事实上,我们会看到,在之后的代码中只有满足这一条件是才会进行旋转). 123456789101112131415161718192021inline void left_rot(int&amp; k)&#123; int t=rt[k]; rt[k]=lt[t]; lt[t]=k; size[t]=size[k]; updata(k); k=t;//运用引用的性质直接更新指针 return;&#125;inline void right_rot(int&amp; k)&#123; int t=lt[k]; lt[k]=rt[t]; rt[t]=k; size[t]=size[k]; updata(k); k=t; return;&#125; 这就是Treap新增的(updata似乎都不算新增的)基本操作.这些将帮助我们再各种操作中保持这棵树的性质.关于旋转不会影响整棵树的性质的证明是显然的,懒,不证明了. 插入数据这是二叉搜索树的基本操作.在Treap中,它的前半部分操作和搜索树是几乎一样的,只是增加了为w(随机权重)赋值.因此这部分操作直接给出代码,简单注释.事实上,Treap仅在原来的基础上添加了两句话,意义是相同的:如果插入节点的随机权值破坏了结构,用适当的旋转修正之. 123456789101112131415161718192021222324252627void insert_val(int v,int&amp; t=lt[0]) //同样使用引用,用默认值简化调用代码&#123; if(t==0)//到了叶子节点 &#123; val[rear]=v; w[rear]=rand();//调用随机函数提供随机权重 cnt[rear]=1;//只有一个 size[rear]=1; lt[rear]=rt[rear]=0; t=rear++;//修改指针,移动边界 return; &#125; size[t]++;//无论何种情况,当前节点的size一定会加1 if(val[t]==v)//这个值已经存在了 &#123; cnt[t]++; return; &#125; if(val[t]&gt;v)&#123; insert_val(v,lt[t]); if(w[lt[t]]&lt;w[t]) right_rot(t);//出现不当的结构,旋转修复 &#125;else&#123; insert_val(v,rt[t]); if(w[rt[t]]&lt;w[t]) left_rot(t);//同上,注意旋转方向 &#125; return;&#125; 不难看出,插入操作可以在$O(h)$的时间内完成,其中$h$是这棵树的高度.而之前已经提到过,Treap的期望高度是$O(log\;n)$,因此插入操作的时间复杂度是$O(log\;n)$. 删除数据在Treap上删除数据首先可以分为两种情况,该数据重复多次或是只出现了一次.对于第一种情况,我们只需要更新size的值并对目标节点k执行cnt[k]--即可,是相当简单的.而另一种情况又可以分为三种情况: 当前节点没有任何子节点 当前节点只有一个子节点 当前节点有两个子节点 对于第一种情况,只需要利用引用直接修改其父节点的指针,直接删除当前节点就可以了; 对于第二种情况,直接用那个子节点替换当前节点即可; 对于第三种情况,稍稍有些棘手,我们有两种方式处理这种情况. 第一种方法是直接使用当前节点的前驱节点或是后继节点取代当前节点,这种方法的正确性很显然,效率也很优,但我们这里不会使用这种方法,因为这种方法会导致代码变得复杂而且会增加较多的常数(我承认是我太蒻导致的). 前驱:比当前节点的值小的最大节点 后继:比当前节点的值大的最小节点 另一种方法是按照保持Treap结构要求的方式不断旋转当前节点,递归的删除当前节点,直到某次旋转后满足以上的其他情况,此时即可直接删除.这种方法的正确性同样显然,因此我同样不打算加以证明.在这里我们使用这种方式删除节点. 在删除过程中,我们同样需要维护节点的size值.但是我们不能在向下的过程中就草率的修改途径节点的size值,因为我们没有得到被删除的值一定存在的保证.因此,我们定义删除函数的返回值为bool型,在成功删除后返回true,否则返回false,这样就可以在返回时完成对size的维护. 按照以上的讨论,我们可以写出这样的代码. 1234567891011121314151617181920212223242526272829bool del_val(int v,int t=lt[0])&#123; if(t==0) return false;//删除的值不存在 if(val[t]==v)//当前节点要删除 &#123; if(cnt[t]&gt;1) &#123; cnt[t]--;//重复了超过一次 size[t]--; return true; &#125; if(!lt[t] || !rt[t]) t=lt[t]+rt[t];//有至少一个子节点为空,直接用另一个取代当前节点 else&#123; if(w[lt[t]]&gt;w[rt[t]])&#123; left_rot(t);//适当的旋转 del_val(v,lt[t]);//递归删除 &#125;else&#123; right_rot(t); del_val(v,rt[t]); &#125; updata(t);//不要忘记更新当前节点的数据 return true; &#125; bool tmp;//保存返回值 if(val[t]&gt;v) tmp=del_val(v,lt[t]);//递归的进行删除 else tmp=del_val(v,rt[t]); if(tmp) size[t]--;//如果需要,进行更新 return tmp;&#125; 由于在递归调用过程中当前节点指针总是向下移动的,因此最多会进行$O(h)$次递归调用,删除元素的时间复杂度也就是$O(h)=O(log\;n)$. 至此,我们已经完成了Treap中最复杂的一部分:Treap结构和性质的维护.之后实现的所有操作都是不会修改任何值的. 求某数的排名首先,对排名加以定义如下: 数k的排名是:当前存在的比k小的数的数量+1. 例如:在动态集合(是不是动态集合似乎在这里没关系诶)${1,5,2,3,8,6,4,9,5,5}$中,$5$的排名是5. 我们注意到,在一棵以k所在节点为根的子树中,k的排名就是这个节点的左孩子的size值加上1(视左孩子为空的情况为左孩子的size值为1).因此, 我们可以从树根向下递归的进行求解.任意时刻的情况可以分为三种(设当前节点为k): 当前节点的值就是要进行排名的值对于这种情况,直接返回size[lt[k]]+1就好了.注意处理lt[k]==0的情况. 当前节点的值大于要排名的节点这种情况下直接求要排名的值在当前节点的左子树中的排名就可以了. 当前节点的值小于要排名的值这种情况比前两种稍微复杂一点.在这种情况下,当前节点的左子树中的所有值以及当前结点本身都是小于要排名的值的.因此结果应该是当前节点的左子树大小加上当前节点的值重复出现的次数再加上要排名的值在当前节点右子树中的排名. 这几种情况都不难处理,因此排名的代码非常简单: 123456789101112int rank_val(int v,int k=lt[0])//由于不会修改,不再使用引用&#123; if(k==0) return -1;//查询的值不存在(然而并没有写相应的处理这个错误的代码) if(val[k]==v) &#123; if(lt[k]) return size[lt[k]]+1;//umm并没有很好的利用哨兵节点 return 1; &#125; if(val[k]&gt;v) return rank_val(v,lt[k]); if(lt[k]) return size[lt[k]]+cnt[k]+rank_val(v,rt[k]); return cnt[k]+rank_val(v,rt[k]);&#125; 同样,一次操作中最多由树根进行到叶子节点,每层只会执行$O(1)$条指令,因此时间复杂度仍是$O(h)=O(log\;n)$. 查询排名为某值的数这个操作实质上和上一个操作的思路是几乎相同的,因此这里不再重复思路,直接上代码. 123456789101112int kth_val(int rank,int k=lt[0])&#123; if(k==0) return -1; if(lt[k]) &#123; if(rank&lt;=size[lt[k]]) return kth_val(rank,lt[k]);//排名不超过左子树大小的数一定就是左子树中这个排名的数 rank-=size[lt[k]];//除去左子树中的数,现在要找的是当前节点和其右子树中的排名为rank的数 &#125; if(rank&lt;=cnt[k]) return val[k]; rank-=cnt[k];//再除去当前节点的数 return kth_val(rank,rt[k]);&#125; 同理,时间复杂度为$O(log\;n)$. 查询某个数的前驱设所查询的某个数为v. 我们采用一个非常直观的思路:一路查询到v并继续查询其左子树直到叶子节点,维护其中路径上遇到的小于v的最大值,那就是我们所要查询的v的前驱.查询过程和在普通二叉搜索树中查找某个特定值几乎一样,只是增加了对最大值的维护.代码如下: 1234567891011int pre_val(int v,int k=lt[0])&#123; if(k==0) return 0x7fffffff+1;//到达叶子节点,返回极小值以消除影响(通过自然溢出) int ans=0x7fffffff+1; if(val[k]&lt;v)//当前值可能是v的前驱 &#123; ans=max(ans,val[k]); return max(ans,pre_val(v,rt[k]);//递归调用并返回找到的最大的值(向右子树找更大的值) &#125; return pre_val(v,lt[k]);//递归调用,向左子树找更小的值&#125; 查询某个数的后继和上一个操作的思路完全一样.将max变为min,将l和r以及小于号还有极值反转,就获得了查询后继的代码: 1234567891011int nex_val(int v,int k=lt[0])&#123; if(k==0) return 0x7fffffff; int ans=0x7fffffff; if(val[k]&gt;v) &#123; ans=min(ans,val[k]); return min(ans,nex_val(v,lt[k]);//递归调用并返回找到的最大的值(向右子树找更大的值) &#125; return nex_val(v,rt[k]);//递归调用,向左子树找更小的值&#125; 同理,不难得出,求前驱和后继的操作的时间复杂度都是$O(log\;n)$. 完整模板代码将上面的操作整合起来,写好主函数(话说这个模板题的主函数好复杂,操作太多了),就得到了能够AC这道模板题的代码. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=100010;int rear=1;int val[MAX]; //存储的值int cnt[MAX]; //重复次数int size[MAX]; //子树大小int w[MAX]; //随机权重//使用lt[0]指向根int lt[MAX]; //左子树指针int rt[MAX]; //右子树指针inline void updata(int k) //更新子树大小&#123; size[k]=cnt[k]; if(lt[k]!=0) size[k]+=size[lt[k]]; if(rt[k]!=0) size[k]+=size[rt[k]]; return;&#125;inline void left_rot(int &amp;k) //左旋转&#123; int t=rt[k]; rt[k]=lt[t]; lt[t]=k; size[t]=size[k]; updata(k); k=t; return;&#125;inline void right_rot(int &amp;k) //右旋转&#123; int t=lt[k]; lt[k]=rt[t]; rt[t]=k; size[t]=size[k]; updata(k); k=t; return;&#125;void insert_val(int v,int&amp; t=lt[0]) //插入&#123; if(t==0) //树中无值为val的节点,需要创建 &#123; val[rear]=v; cnt[rear]=1; size[rear]=1; w[rear]=rand(); lt[rear]=0; rt[rear]=0; t=rear++; //利用引用直接修改父节点的相应指针精简代码 return; &#125; size[t]++; //无论如何进行,t的size一定增加1 if(val[t]==v)&#123;cnt[t]++;return;&#125; //值为val的点被找到了,直接累加出现次数 if(val[t]&gt;v)&#123; insert_val(v,lt[t]); if(w[lt[t]]&lt;w[t]) right_rot(t); //如果必要进行旋转 &#125;else&#123; insert_val(v,rt[t]); if(w[rt[t]]&lt;w[t]) left_rot(t); //如果必要进行旋转 &#125; return;&#125;bool del_val(int v,int&amp; t=lt[0])&#123; if(t==0) return false; //val并不存在 if(val[t]==v) //找到了,要删除了 &#123; if(cnt[t]&gt;1)&#123;cnt[t]--;size[t]--;return true;&#125; //如果还存在val直接返回 if(!lt[t] || !rt[t]) t=lt[t]+rt[t]; //如果有一个子节点为空,直接用另一个取代当前节点 else&#123; if(w[lt[t]]&gt;w[rt[t]])&#123; right_rot(t); del_val(v,rt[t]); &#125;else&#123; left_rot(t); del_val(v,lt[t]); &#125; updata(t); &#125; return true; &#125;else&#123; bool tmp; if(v&gt;val[t]) tmp=del_val(v,rt[t]); else tmp=del_val(v,lt[t]); if(tmp) size[t]--; return tmp; &#125;&#125;int rank_val(int v,int k=lt[0])&#123; if(k==0) return -1; //不存在 if(val[k]==v) &#123; if(lt[k]!=0) return size[lt[k]]+1; return 1; &#125; if(val[k]&gt;v) return rank_val(v,lt[k]); if(lt[k]!=0) return size[lt[k]]+cnt[k]+rank_val(v,rt[k]); return cnt[k]+rank_val(v,rt[k]);&#125;int kth_val(int rank,int k=lt[0])&#123; if(k==0) return -1; if(lt[k]!=0) &#123; if(size[lt[k]]&gt;=rank) return kth_val(rank,lt[k]); rank-=size[lt[k]]; &#125; if(rank&lt;=cnt[k]) return val[k]; rank-=cnt[k]; return kth_val(rank,rt[k]);&#125;int pre_val(int v,int k=lt[0])&#123; if(k==0) return 0x7fffffff+1; int ans=0x7fffffff+1; if(val[k]&lt;v) &#123; ans=max(ans,val[k]); return max(ans,pre_val(v,rt[k])); &#125; return pre_val(v,lt[k]);&#125;int nex_val(int v,int k=lt[0])&#123; if(k==0) return 0x7fffffff; int ans=0x7fffffff; if(val[k]&gt;v) &#123; ans=min(ans,val[k]); return min(ans,nex_val(v,lt[k])); &#125; return nex_val(v,rt[k]);&#125;int main()&#123; srand(time(0));//不要忘了设置随机种子! int n,opt,v; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;opt,&amp;v); switch(opt) &#123; case 1: insert_val(v); break; case 2: del_val(v); break; case 3: printf("%d\n",rank_val(v)); break; case 4: printf("%d\n",kth_val(v)); break; case 5: printf("%d\n",pre_val(v)); break; case 6: printf("%d\n",nex_val(v)); break; default: break; &#125; &#125; return 0;&#125; 对完整代码的(胡乱)分析复杂度对于包含n个节点的Treap,其各种操作的时间复杂度在期望意义上都可以在不超过$O(log\;n)$的时间内完成.这一点由随机化保证,因此存在出现效率不佳的情况的可能,但其概率极小.而且很容易得到,即使在数个深度较小的节点处出现了只有一侧子树的情况,其对整体的性能影响也是很小的.因此,即使Treap只是一个平衡树的 “暴力”实现,也可以对其性能有坚定的信心. 进一步优化虽然上面的代码保证了Treap的正确性和一定的运行效率,我们还能做的更好.主要有以下几方面可以进行优化. 替换随机函数确实,C++提供的rand()函数比较方便,但它略大的常数也成为了影响效率的因素(虽然不很明显).因此,可以考虑手写随机函数加以替代.比如这样(原理自行百度,很容易就能找到): 12345int seed=1583;//随机种子的初始值也可以随意inline int rand()&#123; return seed = (int)((((seed ^ 998224373) + 19330819ll) * 19870803ll) % 1000000007); //其实这句中return seed=后面的表达式是可以随便写的,但会影响生成随机数的质量&#125; 构造内存池可以注意到,即使有些节点被删除了,占用的空间也不会被释放:插入新节点时仍会开辟新的空间.这就造成了所谓的内存泄漏.在上面提到的题目中这个问题并不会影响什么,但是作为一个目的是稳定高效的数据结构,同时作为一个好习惯,应该高度关注内存泄漏.因此,可以再实现一个内存池来解决这个问题(不要问我为什么不用链式结构.感觉太丑了). 这个问题中的内存池只需要利用栈或队列之类的数据结构保存被删除释放的空间信息(下标),并在请求时返回相应的值即可.比如这样: 1234567891011121314151617181920212223242526272829struct mem//想不好名字可还行&#123; private: queue&lt;int&gt; q; int rear;//就是之前代码中的rear public: mem() &#123; rear=1;//初始化 &#125; void free(int t)//释放内存 &#123; q.push(t); return; &#125; int allocate(void)//分配内存 &#123; if(!q.empty())//优先分配之前释放的内存 &#123; int tmp=q.front(); q.pop(); return tmp; &#125; rear++; return rear; &#125;&#125;; 之后在之前代码中创建新节点的地方改用mem.allocate()(虽然不可能,还是假设这就是对象名)获取内存,在适当的地方添加mem.free()释放内存. 修改为迭代形式当树很高时(虽然一般你会先超时),递归可能带来栈溢出.而且即使不会,在多数计算机上运行时,递归的效率也一般低于迭代.因此,将递归改为用while循环完成的迭代形式在某些情况下是不错的主意(但是不推荐在不必要时进行,因为这样会导致代码量提升). 封装为结构体在单一的程序中其实没什么必要(尤其是只是为了AC上面的题的话),但是封装进结构体可以让其更直观的作为一种数据结构出现,同时也是当需要操作多个Treap时的最佳选择. 后记虽然是非常暴力的随机化思想,但是无可否认,这样完成的Treap的效率确实很高,而且也很难被卡:甚至作者自己都不知道自己的Treap会干些什么.在一般情况下,为了实现上面题目中的操作,Treap应该会是我的首选吧. 如果哪里出现了什么错误,请路过的大犇不吝赐教,多谢了.]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>平衡树</tag>
        <tag>随机算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图匹配]]></title>
    <url>%2F2018%2F03%2F25%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[umm,本来是作业,介绍一个自己感兴趣的知识,于是写了篇画风诡异的,懒得改了,直接当我的二分图匹配的匈牙利算法的学习笔记吧(怠惰哦)(我完全不知道卡什是谁…) さあ、王の話をするとしよう！ 来讲一个王的故事吧. 降临众所周知,情人节快到了. 什么?情人节已经过了?没关系,我们加一个定语. 众所周知,月球人的情人节快到了. 更加充分一点: 众所周知,生活在中国的月球人的情人节快到了. 在这段万众瞩目的时间里,恐怕会发生很多很有意思的事情吧. 但不幸的是,本该在这期间有所行动的人们很多还不知道该将目标指向谁. 而幸运的是,你出现了.你有一个大胆的设想:按照身边人相互的好感关系,将尽可能多对相互都有好感的男女(忽略其他情况)”匹配”在一起,造福大众! 等等,哪里不对吧.你如何准确的得知身边的人中,谁和谁互有好感? 再等等,为什么你要干这种事?为了自己附近方圆百米只有自己一条单身狗?”旺旺”?似乎解释不通. 让我们来修改一下设定. 你是一个来拯救迷茫的人们的迷之造访者(喂,迷字用得多了点).你用卡什之眼(???)的力量得知了所需要的好感关系.你要做的还是一样,将尽可能多对相互都有好感的男女”匹配”在一起,造福大众,让他们铭记你,感激你,赞颂你. 然而然而在你提出这个大胆的构想之后,你终于发现,你太天真了.虽然身边的人不多,只有$10^1$数量级,但是他们之间的关系最多可以达到$10^2$数量级.而这些关系之间还会互相影响,实在是太过复杂,对于年幼而不擅长数学的你,实在是有些强人所难了.但是之前你已经说过了,”包在我身上了”,看来是没办法了.终究还是不行. 转机就在你几乎放弃的时候,你听说了一种魔术形式:程序.这是一种运行于被称为计算机的魔术介质上的一种东西.使用被正确配置的程序可以迅速完成需要的计算,即使需要考虑的情况复杂.正是智慧,力量,魔术的完美结合.你的眼中仿佛出现了高光.希望!看到希望了!终究,我还是要成为被称颂的王的人! 希望背后当你找到了新世界大门的时候,难以抑制的兴奋感迎面而来.但是,你突然意识到:你没有新世界大门的钥匙.虽然整个方法是存在的,利用那种魔术可以解决这个问题,但你没能力完成它的前提:你没法绘制出正确配置的程序.看着新世界的大门,上面的锁孔,高光消失了.终究还是无能为力…吗? 指引“即使这样说显得很自作多情,但我还是要说,那就是命运的邂逅.”那时,你,和一个至今还不知从哪里来,到哪里去,为了什么而出现的,自称梅莉的人物,邂逅于门前. “哦哦,这样啊,我了~解了.我问你,如果一定要你自己完成的话,你会怎么做呢?比如像这样~?”梅莉边说边画出了一幅简单的关系图,问道. [解说:图上左边的点分别表示男一,男二,男三,男四,右边的是女一,女二,女三,女四(心疼女四半秒),线表示两人互有好感] “嗯…这张图倒是简单.那么,先把男一和女一分配到一起吧.” “正解!下面呢?” “嗯,那么再把男二和女二配成一对吧!” “嗯,嗯.” “下面的话,男三…啊,和男三有好感的都被配上对了!怎么办啊!” “没关系啊,我们将之前的配对断键,试着给男三也配对啊” “哦,那么我看看…女二和男二成键了…女二还可以和…诶?女一也被分配过了!” “嗯~,那么,怎么办呢?我们手中似乎已经有了足够的工具解决这个问题了哦~“ “莫非,对于目标已经被分配了的男二,用同样的方法在进行一次吗?” “完全正确!这就是所谓的递归啊!” “再重新为男二查找,再为男一查找…啊,男一可以和女三配对,那么男二就可以和女一,男三就可以和女二了!” “果然被选中的人最棒了!” “嗯!…嗯?” “没,没什么.看,看男四怎么办!” “男四…无论怎么调整都不能配上对啊…看来需要心疼的不只是女四啊…” “嗯,没错!这样,这个问题就解决了哦~❤” “喂,为什么用那种令人起疑的语气!” “ひみつ.” 曙光&amp;王座似乎,知道了啊. 虽然很后悔没能在那个自称梅莉的人离开之前多和她说上几句话,但是至少找到了解决的方法.还真是要谢谢她.嗯…还是有些在意,有些细节… 于是,在掌握了解决问题的方法之后,你又经过了一段时间的研究,掌握了刻画能够在魔法介质上工作的魔术的方法.终于,能实现了. 你叫来了那些人,向他们展示了自己的成果,并解释了一些细节. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;//每个人本有一个编号//但是为了能够处理问题//必须将男女分别从1到n(男生数),m(女生数)编号//因此需要对照表const int id[]=&#123;0,1,2,3,6,7,10,13,16,18,19,21,23,24,25,26,27,32,35,36,38,41,4,5,8,9,11,12,14,15,17,19,20,22,28,29,30,31,33,34,37,39,40&#125;;const int MAX=1010&lt;&lt;1;int n,m; //意义见上面int map[MAX][MAX]; //用于表示关系int pi_bond[MAX]; //记录配对的人是谁bool failed[MAX];//一次寻找中如果某个人无法重新配对//那么这次寻找中他将始终无法重新配对//因此加以记录可以节省时间bool find(int x) //为男x配对.返回是否成功&#123; for(int i=n+1;i&lt;=n+m;i++) if(map[x][i]) //尝试每个可能情况 &#123; if(!pi_bond[i]) &#123; pi_bond[i]=x; //男x与女i配对成功 return true; &#125; if(!failed[i]) //可能能重新配对 &#123; if(pi_bond[i]!=x &amp;&amp; find(pi_bond[i]))&#123; pi_bond[i]=x; //重新配对成功了 return true; &#125;else&#123; failed[i]=1; //失败了 &#125; &#125; &#125; return false; //完全不行啊&#125;int main()&#123; int x,y,e; scanf("%d%d%d",&amp;n,&amp;m,&amp;e); //读入男女数和关系数 for(int i=1;i&lt;=e;i++) &#123; scanf("%d%d",&amp;x,&amp;y); //男x与女y互有好感 if(y&lt;=m) map[x][n+y]=1; //记录 &#125; int ans=0; //记录最大匹配数 for(int i=1;i&lt;=n;i++) //为男1到男n尝试匹配 &#123; memset(failed,0,sizeof(failed)); //上次不可能再次分配的这次不一定 //因此要还原 if(find(i)) ans++; //如果成功了的话就累加 &#125; printf("\nsum=%d\n",ans); //告诉大家能匹配多少对 for(int i=1;i&lt;=m;i++) &#123; if(pi_bond[n+i]) printf("%d with %d\n",id[n+i],id[pi_bond[n+i]]); else printf("%d single all the way.\n",id[n+i]); //对每对,女前男后的输出其原始编号 //对于没成功匹配的,输出... //没成功匹配的男x,抱歉,不会提到你的 &#125; return 0;&#125; 接着,你拿出了你用卡什之眼的力量(???)得到的关系表(万万没想到这有这么点): 21 20 5 4 1 4 15 5 10 9 15 16 5 然后将表提供给了设置好的程序.不负众望,你得到了结果! sum=4 4 with 6 5 single all the way. 8 single all the way. 9 single all the way. 11 with 27 12 single all the way. 14 single all the way. 15 single all the way. 17 single all the way. 19 with 7 20 single all the way. 22 single all the way. 28 single all the way. 29 single all the way. 30 with 18 31 single all the way. 33 single all the way. 34 single all the way. 37 single all the way. 39 single all the way. 人们在欢呼.仿佛划破黑暗的曙光. 而你,将加冕为王 卡什之眼你曾加冕为王. 然而,你得到的是不完全的关系图.而且最致命的是,这甚至并非是严格的”互有好感”,而只是单方面的.(真是悲伤).(不过你想想,卡什之眼什么的这种东西靠谱吗) 你离开了王座,和一位名叫akua的神见了面. 但你留下的处理这种问题的方法被人铭记,并称之为”匈牙利算法”.(真是可惜,连冠名的机会都没有). 人们仍不知道,你那天所见的,自称为梅莉的人,的真实身份. 完. 梅莉“这就是王的故事.王是不幸的.他依赖了错误的力量(所以说卡什之眼究竟是个什么鬼啊),而且最严重的是,他错误的配置了那个魔术而自己还浑然不觉.” “哦?是吗?究竟是哪里?”认真听着眼前的迷之少女讲述的王的故事的你并没有注意到问题出现在了哪里. “哈,还没看出来吗?仔细想想,会不会出现一个元素被匹配多次的情况?嘿嘿,说多了就没意思了~” “好像是这样诶.那么,其实应该怎么配置?” “像这样就可以了哦” 少女随手摆出了这样的东西. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;//每个人本有一个编号//但是为了能够处理问题//必须将男女分别从1到n(男生数),m(女生数)编号//因此需要对照表const int id[]=&#123;0,1,2,3,6,7,10,13,16,18,19,21,23,24,25,26,27,32,35,36,38,41,4,5,8,9,11,12,14,15,17,19,20,22,28,29,30,31,33,34,37,39,40&#125;;const int MAX=1010&lt;&lt;1;int n,m; //意义见上面int map[MAX][MAX]; //用于表示关系int pi_bond[MAX]; //记录配对的人是谁bool visited[MAX]; //在本次搜索中是否被访问过bool find(int x) //为男x配对.返回是否成功&#123; for(int i=n+1;i&lt;=n+m;i++) if(map[x][i] &amp;&amp; !visited[i]) //尝试每个可能情况 &#123; visited[i]=1;//标记已访问 if(!pi_bond[i] || find(pi_bond[i]))//i未匹配或是可以重新匹配 &#123; pi_bond[i]=x; //男x与女i配对成功 return true; &#125; &#125; return false; //完全不行啊&#125;int main()&#123; int x,y,e; scanf("%d%d%d",&amp;n,&amp;m,&amp;e); //读入男女数和关系数 for(int i=1;i&lt;=e;i++) &#123; scanf("%d%d",&amp;x,&amp;y); //男x与女y互有好感 if(y&lt;=m) map[x][n+y]=1; //记录 &#125; int ans=0; //记录最大匹配数 for(int i=1;i&lt;=n;i++) //为男1到男n尝试匹配 &#123; memset(visited,0,sizeof(visited)); //上次不可能再次分配的这次不一定 //因此要还原 if(find(i)) ans++; //如果成功了的话就累加 &#125; printf("\nsum=%d\n",ans); //告诉大家能匹配多少对 for(int i=1;i&lt;=m;i++) &#123; if(pi_bond[n+i]) printf("%d with %d\n",id[n+i],id[pi_bond[n+i]]); else printf("%d single all the way.\n",id[n+i]); //对每对,女前男后的输出其原始编号 //对于没成功匹配的,输出... //没成功匹配的男x,抱歉,不会提到你的 &#125; return 0;&#125; “像这样稍加修改,避免在一次匹配中出现重复访问同一个元素的情况,就能得到正确的结果了.” 看着她毫不费力的展示如此复杂的东西,你被折服了.你情不自禁的问出:”我能否有幸耳闻您的大名?” 银铃般的笑声.“你可以称呼我为梅莉哦~❤” 完….? umm……脑洞起来停不下来了.就这么着吧.故事(胡言乱语)算是结束了,脑洞填完了. 蒟蒻而且文笔极差的我在此鞠躬.无论是谁出于什么原因,感谢你看到这里.希望这个故事还算有趣.]]></content>
      <tags>
        <tag>胡言乱语</tag>
        <tag>图算法</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于这个蜜汁博客]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E8%9C%9C%E6%B1%81%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这篇文章主要是为了测试发布新博文以及简单描述一下这个博客. 当这篇博文被看到的时候想必就完成了第一个任务了吧. 这个博客是闲来无事自己(照着网上的教程)轻松(花了几个小时)搭建完成的.将会取代我以前使用的CSDN博客成为我新的(也是唯一的)博客.我博文的新家哦. 博客的主要内容会是我这个蒟蒻的算法和数据结构的学习笔记以及自以为是的写的题解,偶尔会出现因为所见所闻而有感而发写下的随笔(懒,几乎不会出现). 题目主要会来自于一下几个OJ(偶尔也会在一些其他的奇怪的地方水一水题): 洛谷 河南省实验中学的OJ LiberOJ 以下是我在这些OJ上的个人主页(用以印证我是个蒟蒻): luogu/hoetateyo COGS/snake COGS/subarashii(小号) LiberOJ/snake 这个博客刚刚搭建好最最基本的框架,我也是刚刚开始尝试自行搭建博客,因此一定会有很多的Bug,请路过的大佬谅解.当然,如果能在评论中告诉我就更好了,万分感谢! 关于评论,在评论时前两项信息(昵称和邮箱)是必填的(当然内容也是).邮箱不会公开,但是会用于获取你的(如果有的话) Gravatar头像 并加以展示.请善加利用.网址一栏并非必填,但是那个会决定点击你的头像会前往何处.如果你希望自己的站点被访问,可以考虑留下这个信息哦. 在本博客中,任何文章除非单独说明,否则均为原创文章.如果您觉得写的还说得过去,希望转载的话,那是您对我的肯定,我十分高兴,请随意,但请务必在您的文中注明其来源(如果是我的原创文章在文章下面也会有的,否则其来源会在开头写明),谢谢.您可以在左侧边栏上看到授权协议. 如果您愿意和我这个蒟蒻交换友链,我真的是乐意之至,您可以: 在站点评论区评论提出(入口在左侧边栏)(推荐) 发送电子邮件(左侧有邮箱地址) 利用QQ联系(也在左侧) 在此页面下评论(不推荐) 接下来还要干的事 继续美化这个博客 添加一些骚操作(然而水平有限) 添加一个至少高效的展示PDF的东西(还没找到) 已经完成的事 添加评论功能(喂都不会有人看还添加评论功能呢) 把之前在 CSDN博客上的文章搬过来 把之前在洛谷博客上的文章搬过来 啊,对了,请不要问我密码有什么用,我知道它没有用,完全起不到阻止查看内容的作用,我只是希望实现这么一个功能,看着舒服. 就是这样.]]></content>
      <tags>
        <tag>测试</tag>
        <tag>helloworld</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
</search>
