<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[再见,有幸再会]]></title>
    <url>%2F2018%2F04%2F22%2F%E5%86%8D%E8%A7%81%2C%E6%9C%89%E5%B9%B8%E5%86%8D%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[如同预期却又似乎更快一些，我在省选之后迎来了自己的OI生涯的结局。以一个失败的方式结束了自己的竞赛生涯，甚至没能完成所期望的，“即使是迎来结局的时候，即使仅此一次，我也想稍稍闪耀一下，至少得一个漂亮一点的分数”的天真愿望。犯下了不少愚蠢的错误的我，错过了这最后的机会。在自责了几天之后，才终于冷静了下来，写下这些话。我似乎没有资格说些什么，作为一个完全失败的，一事无成的OIer。但是即使只是任性，我也想在迎来结局之后，将自己最后想说的话说出来。 关于过去 这里的故事比较久远，虽然对事件的记忆比较清晰，但没法保证事件之间的先后顺序完全正确。 一切的开始仔细想想，我是从初一就开始学习信息学竞赛的。那个时候的我完全不懂什么是竞赛，更不要说什么信息学竞赛了。我参与的唯一原因就是因为在那里可以接触到电脑，可以玩游戏而不受到家长的约束。那几乎是我参与竞赛课程的唯一理由。因此，在那一段时间里，我只学了一点点最基础的东西（比如语法），大部分的时间都用来玩游戏了。要说起来学得最精通的，就是如何格式化别人的代码，让它“看起来像”是我写的（当然这大多数情况下并骗不过老师）。同样因此，那时的我大概是老师管理起来最困难的学生吧。真的是给老师添了不少麻烦，在这里先说一声，对不起。 在我初一的时候，刚刚接触信息竞赛不久，老师就带我去参加了CCC（加拿大计算机竞赛）。参赛的主角是我的几个学长，老师说完全没有要求我能获奖，只是尽力试着得到一些分数，并增长一些见识。于是我对着题目和英语词典（题面是英语的，允许携带词典）研究了好几个小时（记不清楚考试时间是多长了），代码写写删删改改，最终爆了零。至于我的几位学长，我已经不记得他们的成绩如何了。但我记得（希望没记错）他们中是有人曾经参与过NOI，而且获得了银牌的，想必成绩不会差吧。 虽然爆了零，虽然当时还没有对于竞赛的丝毫认真了解，我还是很感激老师，感谢老师给了我一个机会，让我早早的看到自己希望到达的层次是什么样的，是需要什么样的水平的。现在看来，这种感激更是强烈。但是当时的我没有想的这么深刻，甚至没怎么因此而改变自己对待竞赛的态度。 初二，出局&amp;回归可想而知，我完全没有静下心来学什么真正的知识，因此在第一次参加NOIP普及组时，我本着玩的心态去参加（当时还迷之自信觉得自己很厉害），自以为能有$200$分以上，结果第一题没仔细读题（还记得珠心算测验吗），第二题想复杂了以至于爆零，三四题完全不会，一共得了$20$分，三等奖。而我的同学已经有人得到了一等奖。紧接着，我在期中考试中同样遭遇了失败。因此，我在之后的很长一段时间里被禁止参加竞赛课和之前一直参加的学校组织的数学提高课。 那次期中考试之后的几周，应该是我初中时期最消沉的一段时间了。我无法相信自己的竞赛只得了$20$分，无法相信自己和同学相差了$200$多分，无法相信自己会被禁止参加竞赛课，尤其是虽然有同学只得到了$0$分，他们也没有遭到这样的对待。我完全成了一个局外人。我没法接受。我坚持每天到班主任那里，要求重新参加竞赛。这件事我坚持了数个月，即使被老师要求别再来了，被我的家长说是在自取其辱，即使被同学嘲笑。 后来，在几个月的坚持之后，我终于得以重新回到竞赛组。然而同学已经学习了很多新的东西了。老师给我说明了在我自认为正确解出的两道题中我所存在的问题，并讲解了正确的解题思路和方法。这更让我意识到我还差了很多。因此，从这时开始，我下定决心，要追上同学们的进度，并且还要超过他们。 初三，成功&amp;抉择在下一次NOIP普及组之前，我跟随进度学习的同时，将之前错过的内容也全部学习了。在这期间，老师给予了我很多非常重要的帮助。在复赛之前的一个多月中，我更是每天中午前去机房刷题，晚上在完成了作业之后还要刷题。我刷题的时间远超过了老师要求的每天一小时的做题时间。因此，我在那年的NOIP普及组中获得了$240$分，获得了普及组的一等奖。然而，我希望追赶的同学已经参加了提高组，获得了三等奖，我因此没能和他们比试一番。不过既然他们参加的是比我参加的更高一级的赛事，想必还是我输了吧。 在那之后，我还没有得意多久（现在想来有什么好得意的），坏消息就又来了。我的课内学科几乎全线“爆零”（看看标题，当时我初三），我因此被从最好的班级，一班，被重新分配到了最后的三班，并远离了与学校的高中签约的机会。 对于当初早早签约进入初中，又一直有着不错的成绩的我，这巨大的反差给了我很大的打击。当时的我还太不成熟，在这种情况下，经受了打击后，我急于恢复平衡，急于重新获得其他人的认可。因此当物理老师找到我，和我说现在正在寻找参加物理竞赛的同学，所有都是从一班（签约的那些同学中）找的，还要找几个认为有潜力的其他班的同学，并问我是否愿意参加的时候，我没怎么犹豫就决定参加了，并因此放弃了信息竞赛。或许是家长的隐约的对我参加信息竞赛的担忧，对参加物理竞赛对文化课的帮助的认可，以及当时信息竞赛不受学校重视的事实，使我做出了这个决定。同时，还有一位同学因为我的选择，在我的邀请下而同样退出了信息竞赛。当时尚没有在意，现在想来，我因为自己的原因改变了其他人的轨道，让本能取得更好的结果的他（我相信他的实力）最终失去了他的机会，实在是太自私，太无礼，太应该被指责了。但是那位同学确实有些太过高尚，他丝毫没有责怪我。尽管我知道，道歉也没法挽回什么，我还是要说，真的对不起了，兄弟。 就这样，我最划水的一年开始了。 高一，安逸&amp;划水然而一开始的故事并不划水。我的初三一模成绩很差，二模甚至更差：满分$580$，我获得了$510$，倒数$5$名之内。经过的一个多月的努力，终于还是在中考的时候以$561$的成绩卡住分数线考进了我现在的高中。 在这之后，我的竞赛活动完全就成了放松和娱乐的地方。真正的字面意义上的几乎完全没学什么东西，几乎一直在玩游戏，聊天。刚刚经历中考的厮杀，又没有临近的重要考试的压力，这一年十分安逸。凭借着稍稍学习了一点的知识以及不小的运气因素，我成功的在力学竞赛和应用物理竞赛中混了二等奖。这样，莫名其妙而自以为是的休息的一年过去了。 高二，失败&amp;重拾，一切的尽头然而，同样是因为我的没有认真学习和自以为是，在物理联赛（真正有用的比赛）的初赛中，我就因为成绩不佳而失去了继续前进的资格。又是经过了很久的思考，我决定重新回到信息竞赛。这是一步很危险的操作，因为这将是我的最后一次机会，我将需要在两个月内重新拿起之前学习过的知识并学习很多新的知识，才能和其他人竞技。但我意识到，我真正爱的，真正希望得到一些成绩的，还是OI。 我去和老师说明了我的想法。老师立刻表示没有问题，并和我分析了接下来的时间情况，说明了我如果希望获得成绩所需要做的事。多亏了老师的帮助，我才得以尽快的重新拿起放下了一年多的C++，并跟上了进度。 这两个月里，我尽力重新熟悉C++，并且恶补了落下的准备考试需要的各种算法。在老师的指导下我少走了很多弯路，更有针对性的进行了练习。 然而，由于尚不够熟悉和心态的问题而在NOIP提高组中出现了两道题莫名爆零而只得到了$195$分，仅仅一个二等奖，冬令营面临和期末考试冲突的双线作战因而缺勤培训两天，紧接着考试几乎爆零，省选由于各种奇怪的错误，不光无缘省队，就连一个稍稍好看的成绩都没有得到，拿着一个丢人现眼的$48$分从此远离了OI。 这就是我的全部故事。 颇为羞愧的表达感谢说实话，我希望在我进入省队，获得NOI的奖牌，安全退役的时候说出这些话，向一切帮助过我的人表达感谢。而现在，我甚至不好意思说出这些话，甚至没脸见帮助过我的人，不好意思把自己和他们联系起来，因为我的经历十分丢人，我辜负了他们的希望。我觉得老师完全有理由对我说，你不要说我是你的竞赛指导老师。但是即使如此，我也希望传达我的感激之情。 首先感谢我的家长。他们虽然不懂半点OI，有时也会说出些让我厌烦的话，但他们总是支持我的。 感谢老师，没有放弃我这个“麻烦”的学生，没有拒绝我重新回到信息竞赛，还为我提供了非常多的帮助。 感谢这5年中我的5位班主任（话说5年一共有六位老师当过我的班主任诶）。您们非常关心和支持我的竞赛活动，鼓励我要努力，要坚持到底，给予了我很大的动力。 感谢曾经和我一同在竞赛组中学习的同学们。你们虽然渐渐的都离开了，但是和你们一起学习的那段时间应该是我初中最最美好的回忆吧。很可惜，那些我希望比试的同学似乎都没有参加NOIP2018。终于也是没有机会再在赛场上见面吗。 感谢现在竞赛组中的同学。感谢你们没有嘲笑我，感谢你们接受我这个莫名其妙出现的同学为一员。 感谢我班上的同学，尤其是我的前桌和后桌。我的前桌同学在我停课准备期间每天都帮我整理当天下发的作业，并把作业项目整理到一张便签纸上给我（那些便签纸的原件我准备裱起来留做纪念）。后桌同学在得知我失误，听到我说我说心态爆炸的时候立刻打来电话安慰我，让我不再那么悲伤，让我能够更快的恢复平静。 ps.大概感受一下: 或许我列出的有些在其他人看来只是小事，但我清楚，这些都是对我无比重要的。在这里，向您们献上最真诚真挚的感谢。同时，我也要表达我的歉意：抱歉，让您们失望了。 关于现在现在我已经离开信息学竞赛了。很不甘心，但是没有办法。这已经是我最后的机会了。 虽然AFO了，但我还会将OI作为一个爱好吧。而且我也仍然希望将之前希望完成的一些OI知识点的学习笔记继续整理出来放到博客上。就权且当是对我竞赛生涯的回忆了吧。 离开了竞赛，在一小段时间中空闲的时间略微多了起来，因此我打算学习一些Python和JavaScript的内容，扩充自己的知识。还有之前因为竞赛而放下的日语的学习，也要重新拿起来了。 但是总的来说，当前很重要的任务是准备高考了。既然没能在竞赛中取得突破，我就需要在高考中拿到足够好的成绩了。我曾经不断的努力，为了不让自己重新经历初二时那样的悲痛和无力而不断努力，不敢停下脚步。这次也一样。 或许会很伤心，但是，我相信这样一句话： 只要向着更高的目标尽力奔跑，之前的伤痛就会消失在风中吧。 我这次要表演裸分考清华 关于未来关于我的未来恐怕是没有什么可说的。尽管我是以这样的方式遗憾的退出的，本应没资格说这些话，但是我还是希望说出我对于还在信息竞赛路上前行的（比我厉害得多的）学弟学妹们的一些建议。就当是我的任性好了。如果能有帮助，那就再好不过了。 没错，这就是所谓的“关于未来”。 由于基本上是边想边写，想到什么写什么，因此虽然试图确保前后的依赖关系的正确性，但仍然不能确保这些关系足够科学。不能保证以后不会在突然想起来写什么的时候突然更新。 关于平时的学习平时的学习将会是竞赛生涯中时间占比最大的一项（废话），因此重要性不言而喻。一个好的学习方法可以事半功倍。 请不要不求甚解有些知识确实是有些晦涩难懂的，可能刚刚接触很难理解。这个时候，一定不要只试着背下结论而不去理解为什么这个结论可以使用。因为理解结论是如何得到的不仅有助于记忆结论，确保在考试时即使忘记一部分内容也可以重新推导得出，更可以让你明白结论在什么前提下成立。当需要扩展这个结论的时候，更是几乎一定要求能够推倒出结论才可能完成。 试着自己推导一下结论，试着研究一下其他人的推导过程，试着画画图，模拟一下运行过程，都可以帮助你理解原理。即使是在没法理解，也请不要简单的把它扔在一边。试着记住你的问题，有时间就脑补一番，事实上你很可能在一些莫名其妙的时刻恍然大悟。 请不要担心耽误时间在学习一个知识的时候，如果只是背下结论，确实会比较快，至少远快于仔细的看懂推导过程的人。而省下来的时间可以多刷几道题。 但要记得，你几乎不可能见到一道裸模板题出现在考试中。你甚至不可能在正规考试中见到见过的知识点组合方式。往往是几个知识点的组合，这也就需要对模板进行扩展。如果没有理解透知识点，那么这是很难进行的。 由于信息竞赛的黑箱测试形式，即使你知道所有的知识点，如果不能完成结合，你的成绩也和一点也不懂的人有一点区别。因此，没有理解透的知识点实际上等价于没有学。所以，请千万不要把看推导过程当作是浪费时间。 请学会自学竞赛课上老师会有计划的按照进度讲解各种知识。但是，越早的学习更多的知识，就有越多的机会熟练它们，也觉越容易融会贯通。更何况老师需要照顾到尽可能多的人的进度，可能并不能满足你的需要。因此，自学的能力是在竞赛中取得成功的必不可少的能力。一定要学会自学。 确实，没有老师讲解似乎学习起来会很辛苦。但是请相信，那些知识点往往远不及你想象的那么困难。真正开始自学一个知识点，再来评论这个知识点是不是真的难以理解吧。 如果你不清楚该自学些什么，去请教老师，或是请教大佬，也可以去看看考纲要求的内容都有什么。当然，你也可以打开洛谷，搜索“模板”，按难度升序排列，依次处理你没有A掉的题目。 请学会利用资源信息学竞赛的知识点很多，很杂。但是应该相信一点，无论是什么样的知识点，一定会有人写过相关的介绍和讲解。因此，看知乎，百科，大佬们的博客上的文章，文库中的论文都是学习知识点的好途径。如果一篇难以理解，不妨多尝试浏览几篇，找出其中你最能理解的一篇仔细阅读，并有针对性的和其他几篇比对。这样可以让你更快的理解，同时确保不会因为只看一个人的讲解而漏掉某些细节。 还有一个好途径就是题解。不要对查看题解有顾虑。当然，这要建立在你已经深入的思考了这个问题，确信自己确实想不出来更好的方法或是思路了的基础上的。题解可以对当前的题目给你进行详细的说明，从思路到实现。当然，要记得反思自己为什么没能想出这个思路。如果能够总结出来看到什么样的题目应该考虑什么样的思路的规律，那就更好了。 网上还有很多有些的教程动画，可视化的展示更有利于理解。我只知道一个，它提供了很多经典的数据结构和算法的可视化演示。可以到我的博客里的“有用的工具”里看看。 可以尝试写自己的学习笔记很多大佬都在博客上写学习笔记。我在大佬们的影响下也稍稍写了几篇。 学习笔记这个东西，看似实在浪费时间，但实际上确实是对学习大有帮助的。我的建议是，在竞赛课上学习的知识可以看时间考虑要不要进行总结，而自学的只是一定要尽量写一写学习笔记。 自学的时候，保持一个清晰的思路是非常重要的。而书写学习笔记有利于整理思路，同时将别人的描述转换成你更容易理解的描述。 书写学习笔记还提供了一个重新审视知识点的机会。你是不是理解了所有的细节？你有没有对某些细节有所误解？在写学习笔记的时候，试着用给别人讲解的方式书写，当你能够把一个知识给别人讲清楚，你就算得上是掌握这个知识了。 当然，还有一些别的作用。比如同学可以互相在别人的博客上吹捧学习自己不知道的知识，相互攻击指出错误。当很多人都在自学不同的知识点，用博客记录自己的学习笔记的时候，他们的博客的并集就是一个非常有价值的资源，他们的所有人都能从中获益。 多尝试一题多解这似乎是一个浪费时间的建议。一道题能做出来就足够了，没有必要反复的练习。但我认为，尝试用各种方法解一道题不仅很有帮助。它能让你将一些知识点关联起来，开阔你的思维。同时，这还可以提高你的程序编写速度，降低出错率，提高调试的能力。 试着多参加模拟比赛平时的练习当然重要，但是考试的时候你面临的情况是完全不一样的。因此，平时应该尽量多参加一些模拟比赛。洛谷的，loj的比赛都是难度比较适当，质量也相当高的模拟比赛。这些比赛基本都是月赛，因此如果希望参加更多的比赛，可以试着参与一下HackerEarth的竞技场(Arena)。这是一个和在线的真实用户对战的编程游戏。你们将会面对同一道题目，在实现内通过更多的测试点的人将取得胜利并获得积分。这个对战是实时的，我遇到的匹配时间没有超过2分钟（唯一的问题就是题面是英语的）。 以上的各个网站网址都可以在“有用的工具”中找到。 不要害怕孤独没有人能够一直在你的竞赛学习中陪伴着你。你很可能有很长时间需要自己在对新知识的研究或是刷题中度过。因此，不要害怕孤独。这里有我听说过的一句话： 一个人走在路上，形单影只。回首望去，大家都留在远方。回过头来继续前行，这便是所谓坚强。 还有这样的一句： 梦想是否无聊并不是别人来决定的，不管是什么样的梦想，自己拼命努力去追寻才是最重要的。 坚持你的道路，即使没有人和你同路，即使形单影只。同伴可以互相帮助，但请不要被同伴限制了你的发展。（真的还是万分对不起我的那个同学。） 关于考试考试是获得成绩的必由之路，因此掌握一些考试的技巧就异常重要。 请记住自己熟悉的IDE设定这个看起来并不重要。实际上你在实际体验之前很难意识到使用一个界面不熟悉的IDE（哪怕只是使用了不同主题的相同IDE）在编写复杂的代码是会对你造成多大的阻碍。因此，记得记住自己熟悉的IDE环境设定，在考试之前记得将其设置好。 请熟悉编译器的使用不要停留在使用F11编译运行的层次上。要学会如何添加编译器，如何设置编译器，如何打开O2优化（事实上省选的题目几乎都会打开O2优化的。虽然一般来说没有打开O2优化不会超时的话打开了也不会，但毕竟确实存在着出现负优化的情况，还是测试一下为好），如何扩大栈空间等等。 一定要先读一遍所有题目题目的难度排序不一定是从易到难的，你也不一定对于最容易的就有思路，也不一定对于难题就没思路。所以先通读一边题目，看清楚时空限制，估算自己能在某道题花费大概多少时间得到多少分，从而安排解题顺序是很重要的。 一定要看清楚要求要求不仅仅是时空限制。还有一下这些需要注意： 是否需要建立子文件夹：无论是在需要的情况下未建立还是在不需要的情况下建立都会导致你的程序无法被评测，因此一定要看清 是否使用c++11（或其他）标准：这将决定一些特性是否可以被使用 是否打开O2：这个带来的影响很玄学 是否扩大了栈空间：如果没有，如果估算得到的递归层数上界过大（具体是多少我也不太清楚，但一般不要超过$10^5$量级比较好），你就需要放弃递归的方法或是手写栈模拟递归 评测环境：区别主要体现在字符串处理中。Windows下的换行是\r\n，而Linux是\n。这将决定如何处理换行 子文件夹名，源代码文件名，后缀名，输入/输出文件名等等 学会写正确的读写优化很多题目都会有大量的输入输出，甚至有些会明白的写着：输入数据量较大，请使用更快速的读入方式。即使不存在这样的情况，读写优化也可以帮助你卡一卡常数。 事实上，读写优化让你可以参与到读入过程中，你可以在读入每一个字符后进行处理（比如计算哈希值），因此可以简化代码，优化逻辑。 一定记得测试你的读写优化对于负数（和小数，如果有的话）是否能正常工作。 合理的进行模块化尽量把重复多次的相同功能（比如向图存储结构中添加一条边）写成函数。这样不仅能够简化代码，而且当你希望修改这个功能的实现过程中的某个细节的时候，你只需要修改一处而不需要修改所有用到的地方，减少了出错的可能。 如果你的函数很复杂，你可以考虑简要在草稿纸上写下函数名 功能 参数 返回值，以帮助你正确使用，节约时间。当然，如果开了很多数组，也可以用类似的方法标记各个数组的意义。 保持头脑冷静你身边很可能有人刚看了两分钟题目就开始写代码了，也一定会有人像是有$8$双手一样打键盘打得飞快，响彻云霄（当然，这可能是一个人）。你也可能遇到自己怎么想也没有思路的情况。不要慌张，慢慢的把题目看清楚，把能化简的式子化简一下，能展开的展开一下，一定要相信，多推几步就能看出点什么来。毕竟题目出的就是为了让人做的。千万不要贸然动手写没有确认正确的优化算法，那可能浪费时间而且会限制你的思路。 不要放弃任何可能得到的分数可能一道题你真的没有思路。那也不要放弃。大部分题目都有给暴力算法的部分分。这部分分数一定要拿到。 很多题目还有一些约束。比如没有修改，比如保证询问的区间长度等于$1$之类的。对着约束逐个点的特判特解。这些分数是不拿白不拿的，而且还会有很多人没有拿（要不然你以为那些两天爆零的人怎么回事）。 如果有提交答案题，即使想不到解法，也一定要留出时间手玩几个简单的测试点。可能在手玩的过程中就有思路了呢，即使没有，也能得到几个点的分数。 不要覆盖你的历史版本在任何进行大规模修改的时候，不要覆盖。将之前的代码另存为一份以题目名+算法（如求和 树状数组）的文件。你永远不知道你会遇到什么问题，可能你的优化是错误的，可能你的时间不允许你完成新的版本，你可能需要回到之前的版本。因此，保存之前的版本是明智的。 学会使用对拍千万不要相信出题人给出的样例数据。那往往只能起到帮助理解题意的作用，而对查错毫无帮助。我在Day2T2中在区间边界上尝试了各种加$1$减$1$ ，对于样例都能得到正确的结果。因此对拍就尤为重要。 一方面要学会如何编写对拍脚本，同时还要学会如何快速的编写高质量的随机数据生成器。一定要完全按照题目中的约束条件构造数据。自己编写一个大暴力，尽可能不加优化的，最最能保证正确的最纯粹的暴力作为标准答案。 注意检查细节再确认一遍这些东西： 子文件夹是不是按要求建立了（或者是不必建立）？名字对吗？有拼写错误吗？ 源程序名对吗？后缀名对吗？ 输入/输出文件的文件名写对了吗？ 该注释的注释了吗？该取消注释的取消了吗？ 该导入的包都导入了吗？Dev-C++会默认导入一些包，千万不要因为这个而忘记导入导致CE using namespace std是不是加了（有时候莫名其妙的没有加也能通过本地编译，原因不明） 对照数据范围，有没有可能出现中间过程的数据溢出？先除后乘避免溢出有办法确保整除吗？出题人保证了你认为理所当然的数据大小关系吗（比如今年的Day2T2，区间操作，没有保证$l \leq r$）？ 提交文件夹中的文件是不是最新的（想要上交的）？ 最后，最重要的一点，相信自己相信自己的实力，相信自己之前的努力不会白费。一个连自己都不敢相信，不愿相信的人，是没有努力的必要的，因为那没有意义。 再见，有幸再会我的竞赛生涯很是失败。也很不甘心，但是没有办法。现在已经到了要说再见的时候了。 请一定以我这个蒟蒻的故事为教训，不要重蹈我的覆辙了。 你可以问问自己，你真的喜欢信息竞赛吗？你真的爱编程吗？你觉得这是一件美好的事吗？你享受它吗？你愿意反反复复的推导一个式子，为了弄懂一个新知识吗？你愿意调试一道题，即使是反复提交了$12$次，还是WA，把鼠标扔出去，大喊一声“我不调了”，然后又捡回鼠标，继续调第$13$次吗？你能做到学起竞赛来就忘记了玩游戏，甚至觉得写代码比玩游戏还有意思吗？ 你不一定要这样才能取得成功。但是，如果你确实如此，那么，这将是你最强大的动力。无论你被家长和老师如何误解，无论你遇到了什么样的打击，都请不要让这份热爱失去温度。 最后，无论如何，我会祝福你们。希望你们的前行的道路上有星光永伴；希望你们能在自己希望的路上走得更远，看到更美丽的风景，那是我不曾见过的；希望你们的故事永远充满祝福。我如此祝愿，也如此相信。 12hs还奋斗在信息竞赛的道路上的各位，我会期待着你们在NOI2019上的好消息哟！ 以上。 写到一半就已经不知道这个到底是给我自己看的回忆录还是给别人看的回忆录还是给别人看的感谢之词还是给学弟学妹们看的我这个丢人的学长的狂妄自大的“建议”了。所以就干脆混在一起写了。以后再考虑有没有必要拆成几篇吧。]]></content>
      <categories>
        <category>随笔</category>
        <category>OI</category>
      </categories>
      <tags>
        <tag>胡言乱语</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【P1012 拼数】题解]]></title>
    <url>%2F2018%2F04%2F13%2F%E3%80%90P1012%20%E6%8B%BC%E6%95%B0%E3%80%91%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这是洛谷的P1012 拼数的题解.这篇文章先发布于洛谷题解,因此存在和此博客风格略有出入的情况,请忽略. 点击这里直达题目. 讲一个玄学的方法吧.我们可以充分利用STL函数来完成这个题目.然而因为对字符串的恐惧,我不打算用string… 首先我们可以想到进行一次排序.问题就在于排序的优先级.明显要比较两个数拼接是ab大还是ba大,而不是直接补齐位数直接排序(也就是字典序先后比较)(我一开始就是这么错的,反例:321和32显然应该排成32321而不是32132). 我用了一种玄学的方法拼接数字.有一个东西叫做cmath,里面有一个东西叫pow(),还有一个log10().很显然,我们用(int)log10()就可以求出一个数有几位数(得到的结果是位数-1).我们就可以用(int)pow(10,(int)log10()+1)将一个数后面补上另一个数位数个0,之后再把它们加起来就实现了拼接数字.把这个东西写进比较函数(我用的是重载)(其实是之前错误解法的产物,懒得改了),就可以直接sort了!简单高效(常数贼大). 下面是代码. 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int MAX=25;struct num&#123; int val; bool operator &lt; (const num&amp; b)const //重载小于号用于sort比较 &#123; return val*(int)pow(10,(int)log10(b.val)+1)+b.val&gt;b.val*(int)pow(10,(int)log10(val)+1)+val; //用两种方式拼接比较大小 &#125;&#125;a[MAX];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].val); sort(a+1,a+n+1); //sort大法好 for(int i=1;i&lt;=n;i++) printf("%d",a[i].val); return 0;&#125; 就是这样.]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[待填的坑]]></title>
    <url>%2F2018%2F04%2F10%2F%E5%BE%85%E5%A1%AB%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[之前有过各种大胆的想法,好多想写的东西,但是没有时间写.先记下来吧,省得忘了,有时间慢慢填坑.就先不管相互关系了,写的时候再该合并合并好了. 题解类:好像没有.想写的似乎都包含在算法学习和游记里了. 学习笔记类: 线段树 可持久化线段树 Trie 可持久化Trie 卢卡斯定理 fhqTreap(qwqTreap) 莫队算法 ISAP 二分图匹配的网络流做法 计算几何的各种东西 随机素数检验 dfs-SPFA 高斯消元 游记类 BJ2018集训队游记 昔日之影:BJOI2018 随笔类 那个故事 纪录类 使用Hexo+NexT搭建博客以及魔改 (umm感觉坑不大啊…)]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>胡言乱语</tag>
        <tag>备忘录</tag>
        <tag>有生之年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【P1036 选数】题解]]></title>
    <url>%2F2018%2F04%2F06%2F%E3%80%90P1036%20%E9%80%89%E6%95%B0%E3%80%91%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这是洛谷的P1036 选数的题解.这篇文章先发布于洛谷题解,因此存在和此博客风格略有出入的情况,请忽略. 点击这里直达题目. 本人大概是最弱的红名了吧(还是改了,现在是红名了)…一条咸鱼看着周围的大佬们瑟瑟发抖…. 进入正题.这道题暴搜居然没有TLE,心情大好,来发篇题解,希望能帮上有需要的人的忙. 既然放在了过程函数和递归中,首先想到的就是用递归解决.首先考虑得到了一个和,如何判断它是不是质数?朴素方法,设这个数为n,从2至n-1,依此判断是否能整除n,如果发现存在某个整数能够整除n,那么n不是质数,否则是.显然循环次数规模与n相同. 简单优化,显然一个整数n若可以用两个整数的乘积表示,那么其中小一点的约数不会超过$\sqrt{n}$.我们以$60$为例 (试图隐藏我不打算证明的事实) : 60=1*60=2*30=3*20=4*15=5*12=6*10=10*6=.. 显然,当超过$\sqrt{60}=7$时开始前面的数就是较大的约数了.因此,可以将枚举范围缩小到$[2,\sqrt{n}]$,时间复杂度降低到$O(\sqrt{n})$.简要代码如下:123456bool isp(int a)//返回a是否为质数&#123; int sq=sqrt(a);//调用函数求a的算术平方根.注意sqrt()函数在cmath中.提前算出可以避免每次循环都计算一次a的算术平方根,可以减小常数 for(int i=2;i&lt;=sq;i++) if(a%i==0) return false; return true;&#125; 考虑可能需要进行多次判断,即使如此优化仍可能超时,考虑一个更优的方法:注意到相加得到的和最大不超过$1\times10^7$,可以构造一个质数表,每次检查n是否为质数只需要查表即可.如何构造一个这样的质数表呢?显然由质数的定义可以得到,一个质数的任意整倍数(除其自身外)都不是质数,任意一个整数都可以被表示为某(几)个质数的乘积,也就是说任意的整数都是某(几)个质数的整倍数.因此只需将任意一个质数的二倍及以上的整倍数标记为”非质数”,就可以获得这样的一张质数表了.简要代码如下:12345678const int MAX=10000010;bool notp[MAX];//质数表,当notp[i]==0时i为质数.注意开够空间void calp(void)//开始构造质数表&#123; for(int i=2;i&lt;MAX;i++) if(!notp[i]) for(int j=i+i;j&lt;MAX;j+=i) notp[j]=1;//当前的i是质数,因此将其所有二倍及以上的整倍数都设为非质数.注意不要越界 return;&#125; 这样一来就更优了.简单 (胡乱) 分析一波:外层循环将重复约$1\times10^7$次,若$i$不是质数则内层将仅进行$1$次判断,否则在判断后还将进行约$(1\times10^7-i)/i$次赋值操作.实验证明 (再次尝试隐藏自己不打算推式子的事实) ,该函数的循环仅会运行$3.95\times10^7$次,反复改变MAX的值可以发现运行次数与MAX的一次方成正比,即该方法可以在线性时间内构造质数表.为了确认自己已经理解了这一部分,建议先前去完成P3383 【模板】线性筛素数. 事实上,还可以再做两个小小的改变,进一步提高这个算法的效率.外层的for(int i=2;i&lt;MAX;i++)可以修改为for(int i=2;i&lt;sqrt(MAX);i++),而内层的for(int j=i+i;j&lt;MAX;j+=i)可以修改为for(int j=i*i;j&lt;MAX;j+=i).当然,建议将修改后的外层的条件修改为i&lt;LIM,并在循环外加上int LIM=sqrt(MAX);,来避免重复计算带来的时间开销.这两处改动的正确性很显然,可以自己证咯. 到目前为止,我们获得了初始化时间复杂度为$O(n)$,查询时间复杂度为$O(1)$的质数表.下面,我们尝试回到原来的问题,看看我们还缺些什么. 我们需要从n个数中选出k个并计算它们的和.为了暴搜,我们需要寻找一种方法唯一地定义当前状态.很容易想到需要一个集合E表示已选择的数.可以用一个数组visited,标记所有已选的数的visited为1.像是这样:1234//假设选了ivisited[i]=1;cal();//递归调用visited[i]=0;//还原确保之后不会漏选某种情况 可以很容易的利用visited统计已选的数的个数和和.看起来不错.但是不要容易确保不会选重的同时不选漏.比如 a[1]+a[2]+a[5],a[5]+a[2]+a[1] 而且每次查找visited也不够优美,应该还有更简单的解决办法. 很容易注意到,每次只向后看是不会漏选的.举例,如当前选到的数中下标最大的是low,那么选下一个数的时候只从下标为$[low+1,n]$的数中选不会导致缺失情况也不会导致重复 (依然不证明) ,因此可以重新定义当前状态:还须选i个数,当前的和为sum,当前已经看完了下标为k及以前的数.这样就确保了每次不需要检查重复的情况,也不需要管具体选择了哪些书,只要一一枚举k以后的数并递归调用就可以了,极大的简化了问题. 递归边界也不难得出:当还须选0个数的时候,已经选够了,判断当前的和是否为质数,如果是返回1,否则返回0.而非边界的时候则进行枚举,计算所有情况得到的返回值的和并返回,我们的函数返回值即使在当前限定条件下(从下标大于k的数中选i个数,在sum的基础上加上选的数的和结果是质数)的情况数.显然在主函数中调用cal(k,0,0)得到的返回值即为结果(注意,这里的k与函数中的k含义不同,此处于题目描述一致,请仔细确认不同k的含义). 最后还有一个小小的可行性剪枝:若cal函数中发现$n-k&lt;i$则返回0.为了确认理解了k的含义,请自行思考理由. 附上AC代码(上面解释过的部分此处不再加注释):1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;//虽然使用的是c++,但由于c的输入输出更快,倾向于使用c的输入输出using namespace std;const int MAX=10000010;bool notp[MAX];int a[25];//保存数据int n;//函数中需要使用,为了方便设为全局变量void calp(void)&#123; for(int i=2;i&lt;MAX;i++) if(!notp[i]) for(int j=i+i;j&lt;MAX;j+=i) notp[j]=1; return;&#125;int cal(int i,int sum,int k) //再选i个,当前和为sum,看完了a[k]&#123; if(i==0) &#123; if(notp[sum]) return 0; else return 1; &#125; if(n-k&lt;i) return 0; int ans=0; for(int j=k+1;j&lt;=n;j++) ans+=cal(i-1,sum+a[j],j); return ans;&#125;int main()&#123; calp(); int k; //关于输入输出的问题请自行查找资料/请教他人解决 scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%d",a+i); printf("%d",cal(k,0,0)); return 0;&#125; 至此,虽然并没有使用更高效率的方法,我们依然以尚可以接受的时间通过了这道题.强烈建议再去完成P1706 全排列问题,使用类似的方法完成一道题可以加深理解. 补充一下,还有一道更进阶的题目P1691 有重复元素的排列问题 最后,本人蒟蒻一棵 (棵?),有不准确的地方请…用力喷!我会回来改正的. Ps.现在看来当初自己写了些什么东西啊…恥ずかしい… 以上.]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>搜索</tag>
        <tag>暴力</tag>
        <tag>模拟</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[昔日之影:BJOI2018]]></title>
    <url>%2F2018%2F04%2F06%2F%E6%98%94%E6%97%A5%E4%B9%8B%E5%BD%B1BJOI2018%2F</url>
    <content type="text"><![CDATA[嘛,这个坑以后再填. 这篇文章旨在记录BJOI2018之前的一段时间和之后的一段时间的我的故事.同时,也将让我明白,我曾经为之如何奋斗.这篇文章将在BJOI2018 $D_{i(i&gt;=3)}$开始不再置顶. BJOI2018 $D_{-1}$终于,到了这一天了.明天就要省选考试了.这一周里我一共学习了16个知识点,AC了103道题目.我相信这些努力是不会白费的.即使不能让我在省选中胜出,也能让我取得一个自己能够满意的成绩. 总而言之,I will AK BJOI2018祝我,祝愿任何一个参加省选的人,都能如愿以偿(天真…). 以上. BJOI2018 $D_{i(i&lt;=-2)}$这里将会记录在省选之前我所做的准备. 计数共计学习了16个知识点! 共计AC了103道题目! がんばります… 学习的知识 学会了的 可持久化线段树 Trie 可持久化Trie 后缀数组 卢卡斯定理 分块 莫队算法(好简单…) bitset fhqTreap(基本上吧) 计算几何(常见的基本上没问题) 欧拉函数(基本上没问题了) 莫比乌斯反演(问题不小) 高斯消元法 割点 缩点 负环判断(dfs-spfa) 正在学的 模拟退火 LCT 点分治(淀粉质)(你到底还学不学了..)(不打算学了.jpg) 还要学的 快速傅里叶变换 乱七八糟的其他东西(毕竟学会的越多越好) 做题列表 2018/4/3 P3919 【模板】可持久化数组(可持久化线段树/平衡树) 模板(问题不大) 2018/4/4 HDU1251 统计难题 trie(问题不大) UVA11362 Phone List trie(问题不大) P3809 【模板】后缀排序 模板(问题很大) P3807 【模板】卢卡斯定理 模板(问题不大) T24743 永世隔绝的理想乡 模拟,坑题(没问题) 2018/4/5 P1691 有重复元素的排列问题 STL函数应用(滑稽) P3414 SAC#1 - 组合数 二项式定理(没问题) P1869 愚蠢的组合数 Lucas定理(应该没问题了) BNUOJ53080 塞特斯玛斯塔 模拟(滑稽) T23806 Sum of a and b 模拟,坑题(滑稽) T26520 Saberの暖心福利 模拟(滑稽) T26021 凛の车厢重组 归并排序,逆序对(应该没问题) T26020 Archerの第K小数 计数排序(没问题) T26019 凛の数字统计 Treap平衡树(应该问题) T25221 SaberのA+B问题 模拟,大整数加法(没问题) 2018/4/6 T26018 Archerの昆虫繁殖 模拟(没问题) T26551 lyf and Archerの作业 模拟,坑题(没问题) T26544 有趣の数列之233 模拟,猜测题意(没问题) T26553 Saberの骑士之战 链表,模拟(现在应该没问题) A + B Problem 线性筛质数,模拟,坑题(应该没问题) 野兽先辈万物说 字符串处理,哈希,并查集(应该没问题) 2018/4/7 U23063 质数 数论,哥德巴赫猜想(应该没问题) U23072 函数 数论,瞎搞(胡乱一通瞎搞就AC了我也是一脸懵)(链接中的题的SPJ有很大的问题…) 2018/4/8 P1972 【SDOI2009】HH的项链 莫队算法(应该没问题) T22196 1-1.小朋友的糖果 无话可说 T22197 1-2.分数 无话可说 T22199 1-4.比身高 无话可说 T22200 1-5 津津学数学 无话可说 T22205 1-6 有多少个6 无话可说 T22206 1-7 比大小I 无话可说 T22422 1-8 学生人数 无话可说 T26802 1-10.数据分离 无话可说 P1903 【国家集训队】数颜色 带修改的莫队算法(应该没问题) P2709 小B的询问 复杂的莫队算法(没问题) P3674 小清新人渣的本愿 复杂的莫队算法,压位,bitset(有点问题) P1494 【国家集训队】小Z的袜子 更复杂的莫队算法,数论(应该没问题) 2018/4/9 P3369 【模板】普通平衡树(Treap/SBT) fhqTreap(问题不小) P3391 【模板】文艺平衡树(Splay) fhqTreap(问题小多了) 这个OJ上的竞技场题目5道 包括欧几里得,线性筛,网络流啥的.只可惜不知道题目名字都叫什么. 2018/4/10 POJ 3580 SuperMemo fhqTreap(感觉没什么问题了A了这道题之后) AT 820 おいしいたこ焼きの食べ方 无话可说 NEFUOJ 919 最最难的题 计算几何,叉乘求三角形面积(应该没问题) NEFUOJ 920 关于种地的忧伤故事 计算几何,叉乘求凸多边形面积(没问题了) NEFUOJ 922 线段相交 计算几何,判断线段相交(应该是没问题) HDU1174 爆头 计算几何,点到直线距离,三维向量(没问题) HDU1392 Surround the Trees 计算几何,凸包(没问题了) 2018/4/11 ZOJ1081 Points Within 回转法判断点是否在多边形中(没问题了) HDU3501 Calculation 2 欧拉函数的直接应用(没啥问题) POJ2480 Longge’s problem 欧拉函数的综合应用,数论(问题不大) P1290 欧几里德的游戏 简单博弈论,模拟,简单数论(问题不大) E-olymp90016 Two-digit number from three-digit 模拟,小坑(没问题) E-olymp90017 Massive Numbers 数论,对数性质(没问题) E-olymp90018 Wall 模拟,坑(没问题) E-olymp90019 Number of zeroes in factorial 数论(没问题) E-olymp90020 Assignments 模拟,坑(没问题) E-olymp90021 Happy Camper 模拟,坑(没问题) E-olymp90022 Root of the Problem 数论(没问题) E-olymp90023 Box 数论,模拟,找规律(没问题) E-olymp90025 Diagonal 数论,找规律(没问题) E-olymp90026 Bob and balls 数论(没问题) E-olymp90027 Inverse Triangular Numbers 数论(没问题) E-olymp90028 Triangular web 数论(没问题) E-olymp90029 Quadrilateral 计算几何,向量点乘(没问题) E-olymp90030 Triangle 数论,几何,坑(没问题) 2018/4/12 P2522 【HAOI2011】Problem b 莫比乌斯反演,分块,数论(有点问题) P1049 装箱问题 动态规划,记忆化搜索(没问题) P1164 小A点菜 动态规划,记忆化搜索(没问题) P1140 相似基因 动态规划(没问题) P1280 尼克的任务 动态规划(没问题) 2018/4/13 P3389 【模板】高斯消元法 模板题(没啥问题) P3388 【模板】割点（割顶） Tarjan求割点,模板题(没问题) P3385 【模板】负环 dfs-spfa,模板题(没问题) P3387 【模板】缩点 Tarjan缩点,模板题,DAG上的DP(没问题) P2004 领地选择 模拟,前缀和(没问题) P1313 计算系数 二项式定理,卢卡斯定理,费马小定理,快速幂(没问题) P1029 最大公约数和最小公倍数问题 模拟,欧几里得算法(没问题) P1030 求先序排列 树的遍历,递归,分治(没啥问题) P1031 均分纸牌 模拟,贪心(没问题) P1024 一元三次方程求解 二分查找(没问题) P1287 盒子与球 stirling(没啥问题) P1012 拼数 无话可说 P1151 子数整数 无话可说 P1420 最长连号 无话可说 P1888 三角函数 无话可说 P1634 禽兽的传染病 无话可说 P2084 进制转换 模拟,坑(没问题) P1150 Peter的烟 模拟(没问题) P1482 Cantor表（升级版） 欧几里得算法(没问题) P3742 umi的函数 无话可说 P1554 梦中的统计 无话可说 P2192 HXY玩卡片 无话可说 P1615 西游记公司 无话可说 P1179 数字统计 无话可说 P1876 开灯 数论(没问题) P1664 每日打卡心情好 无话可说 P1116 车厢重组 逆序对,归并排序(没问题) P1314 聪明的质监员 二分答案,前缀和(没啥问题) P1351 联合权值 模拟,有技巧的枚举(没问题)]]></content>
      <categories>
        <category>随笔</category>
        <category>OI</category>
      </categories>
      <tags>
        <tag>胡言乱语</tag>
        <tag>昔日之影</tag>
        <tag>未完成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树学习笔记]]></title>
    <url>%2F2018%2F04%2F03%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[刚刚学习了可持久化线段树,AC了洛谷上的模板题,来总结一波这个看似复杂的数据结构吧(其实一点也不难的,我这么弱都一遍写对了). umm仔细想了想,就从基础的线段树开始吧. 考虑一类问题.给你一个序列,让你进行以下的操作: 将区间$[l,r]$中的所有值加上$v$ 查询区间$[l.r]$中的所有值的和 查询区间$[l.r]$中的所有值的积 查询区间$[l.r]$中的所有值的最大值 查询区间$[l.r]$中的所有值的最小值 甚至是像这样,还要你支持这样的操作: 将区间$[l.r]$中的所有值乘上$v$ 查询区间$[l.r]$中的所有值的最大公约数 等等.这些操作都有这样的共同点: 对区间进行操作或是查询 可以由任意两个区间的结果迅速(一般是$O(1)$)计算出这两个区间合并后得到的新区间的结果 对于这样的问题,我们有一个非常强大的工具,就是线段树.线段树可以支持以上的所有操作,而且思路非常清晰,代码也很简洁(但是我太菜所以写不简洁也写不漂亮),其除初始化的所有操作的时间复杂度均为$O(log\;n)$(初始化的复杂度是$O(n)$). 线段树的实现思路显然,在线性结构上实现区间的高速操作是不太现实的(据我所知),因此我们采用树状结构,利用分治的思想,将整个序列一分为二,再把得到的两个序列分别一分为二,知道得到的子区间 umm…等着填坑.]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>未完成</tag>
        <tag>可持久化</tag>
        <tag>线段树</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有用的工具]]></title>
    <url>%2F2018%2F03%2F31%2F%E6%9C%89%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[来总结一些有用的(有意思的)工具.先胡乱分类吧,毕竟东西少.等东西多了再仔细考虑分类. 图示工具(什么鬼名啊,我果然对起名没半点思路) csacademy/grapheditor:一个在线的图生成模块,可以根据输入快速生成一张图,还可以一键生成成树的形状. 让我帮你百度一下 生成一个链接,可以展示一个动画嘲讽不会百度的人,然后给他百度…(这真是OI工具吗…) 数据结构和算法可视化 字面意义的.甚至在一些方面的展示效果比第一个还好!只是中文做的跟没有一样… 博客用到的工具 simimg 一个图床.免费的.感觉界面也很友好,还没怎么用呢.如果好用以后这个博客的图床就用这个了. 各种OJ合集 洛谷 目前主要在用这个.服务器稳定,速度快,用户也多,题目质量很高,还有题解. COGS 这似乎不是它的名字…这里使用文件读写,算是比较少见的,题目质量还可以,界面比较美观,然而现在热度不高,管理的效率不高.可以下载测试数据(没有通过的第一个测试点的) LiberOJ 界面美观,有官方月赛(似乎不定期??),题目质量挺高的,测试数据完全公开,包括SPJ,但是访问速度比较慢. Virtual Judge 这里集合了很多著名OJ的题目(如UVA,POJ,CF,SPOJ等等),采用RemoteJudge,可以避免注册一堆帐号,而且避免了访问那些服务器不在国内的OJ时的连接缓慢和不稳定的问题,(界面也不知道比好多大学的OJ优美到哪里去了). Hackerearth 竞技场很好玩… E-olymp UI非常优美的OJ,题库体量比较大(8000+题目),几万页面的注册用户,评测的等待时间极短,没有出现过洛谷出现的卡顿情况,非常喜欢(虽然vjudge也支持这个OJ,但是和这个OJ的UI相比vjudge就显得简陋了).]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>奇技淫巧</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大流算法之ISAP]]></title>
    <url>%2F2018%2F03%2F30%2F%E6%9C%80%E5%A4%A7%E6%B5%81%E7%AE%97%E6%B3%95%E4%B9%8BISAP%2F</url>
    <content type="text"><![CDATA[网络流(最大流)实在是个玄而又玄的东西.就是一个异常简单的模型,可以想象成是一个管道网络,各个管道有各自的单位时间最大通过的流量,问单位时间从其中某一个点(源点)到另一个点(汇点)能通过的最大流量.但是这个东西却能解决很多问题,其中的一些问题甚至看起来还和这个模型没啥关系,但是巧妙地构建关系建立出一张图之后就会发现,这玩意居然能用最大流的思想解. 因此,掌握一种快速求解最大流问题的算法就异常重要了.大名鼎鼎的 Ford-Fulkerson算法 的效率过低, EdmondsKarp算法 虽有改进但是依然不够,直到 Dicnic算法 运用类似启发式搜索的思想将时间复杂度降低到$O(V^2E)$,才刚刚称得上是比较高效.而在此基础上,采用类似思路的 ISAP算法 则使用了动态的层次图,省略了Dicnic算法中BFS的过程,效率进一步提高(虽然理论的时间复杂度没有改变,仍然是$O(V^2E)$). 虽然初次用ISAP水过了洛谷的 最大流模板题 ,但是依然担心自己还是没有掌握,于是在这里总结一下. 前置知识ISAP的代码很简单,在Dicnic的基础上也比较容易理解.因此再研究ISAP之前要先研究这些: 网络流的基本概念 Dicnic算法 链式前向星(邻接链表) ISAP的基本思想ISAP的思路的Dicnic是几乎一样的,生成(计算)每个节点的高度,层次(定义为当前节点到汇点的最短距离),搜索中每次前进只会走到高度比当前节点低1的节点,因此能保证总是向着汇点前进的,避免了向着反方向或是同层访问一些多余的节点,是典型的启发式搜索. 那么就会遇到一个问题:如果在某个节点,我们发现无路可走了,怎么办?如果是这个点不可能再向它连接的其他节点发送流量了,那么似乎还没有什么问题;如果无路可走是因为高度的限制,会不会损失一部分解? 这就是ISAP的核心:重贴标签.当我们发现出现了这种情况,我们重新标记当前节点的高度.为了不漏掉某些解,显然我们应该将它的高度设为比它连接的且边上还有富裕容量的节点中高度最小的节点大1.这就是所谓的 重贴标签. 具体实现]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>未完成</tag>
        <tag>算法</tag>
        <tag>图</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读写挂测试&怀疑人生]]></title>
    <url>%2F2018%2F03%2F25%2F%E8%AF%BB%E5%86%99%E6%8C%82%E6%B5%8B%E8%AF%95%26%E6%80%80%E7%96%91%E4%BA%BA%E7%94%9F%2F</url>
    <content type="text"><![CDATA[众所周知,在信息题目中,有一个非常令人头疼的问题就是TLE.同样众所周知的还有一个词语,叫做卡常数.就像这样: “这道题时间复杂度没问题,怎么调都TLE” “卡卡常就过了/优化优化常数就过了” 然而,有时会被针对,即使主要过程中的复杂度和常数都很优,读入的过程就已经足以使得你的程序TLE.这时候就需要读写优化了. 经验告诉我们…一般来说,c++中的各种方式进行读写的速度对比是这样的:v(cin,cout)&lt;v(cin,cout(关闭流同步))&lt;v(scanf,printf)&lt;v(读写挂).针对这一点,我进行了一些测试(然后开始怀疑人生) 生成数据我采用了一个极为简单的程序随机生成$10^6$个整数存入文件,作为测试用的数据.程序代码如下: 1234567891011#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;using namespace std;int main()&#123; srand(time(0)); freopen("data.in","w",stdout); for(int i=1;i&lt;=1000000;i++) printf("%d ",rand()); return 0;&#125; 对cin与cout进行测试首先我使用cin和cout对测试数据进行读入并立刻输出至标准输出,用ctime中的clock()函数计时,并将运行时间写入文件.代码如下: 123456789101112131415161718#include&lt;fstream&gt;#include&lt;iostream&gt;#include&lt;ctime&gt;using namespace std;ifstream fin("data.in");ofstream fout("test1.out");int main()&#123; double time0=clock(); int tmp; for(int i=1;i&lt;=1000000;i++) &#123; fin&gt;&gt;tmp; cout&lt;&lt;tmp&lt;&lt;" "; &#125; fout&lt;&lt;"Cost "&lt;&lt;(int)((clock()-time0)/CLOCKS_PER_SEC*1000)&lt;&lt;"ms."&lt;&lt;endl; return 0;&#125; 在测试后我得到了这样的结果: Cost 129151ms. 共花费了129151毫秒,约129秒,2分钟. 对关闭流同步的cin与cout进行测试我同样使用cin和cout对测试数据进行读入并立刻输出至标准输出,用ctime中的clock()函数计时,并将运行时间写入文件,但这次在开始之前我先关闭了cin,cout与stdio的同步,因为这个同步操作将带来不小的时间开销.代码如下: 12345678910111213141516171819#include&lt;fstream&gt;#include&lt;iostream&gt;#include&lt;ctime&gt;using namespace std;ifstream fin("data.in");ofstream fout("test2.out");int main()&#123; ios::sync_with_stdio(false); //关闭流同步 double time0=clock(); int tmp; for(int i=1;i&lt;=1000000;i++) &#123; fin&gt;&gt;tmp; cout&lt;&lt;tmp&lt;&lt;" "; &#125; fout&lt;&lt;"Cost "&lt;&lt;(int)((clock()-time0)/CLOCKS_PER_SEC*1000)&lt;&lt;"ms."&lt;&lt;endl; return 0;&#125; 在测试后我得到了这样的结果: Cost 1640ms. 共花费了1640毫秒,约2秒. 对scanf与printf进行测试这次使用scanf和printf对测试数据进行读入并立刻输出至标准输出,同样用ctime中的clock()函数计时,并将运行时间写入文件.代码如下: 1234567891011121314151617#include&lt;cstdio&gt;#include&lt;ctime&gt;int main()&#123; FILE* fin=fopen("data.in","r"); FILE* fout=fopen("test3.out","w"); double time0=clock(); int tmp; for(int i=1;i&lt;=1000000;i++) &#123; fscanf(fin,"%d",&amp;tmp); printf("%d ",tmp); &#125; fprintf(fout,"Cost %dms.\n",(int)((clock()-time0)/CLOCKS_PER_SEC*1000)); return 0;&#125; 在测试后我得到了这样的结果: Cost 216750ms. 共花费了216750毫秒,约217秒,近4分钟. 事情的进展开始超出了我的想象. 对读写挂的测试最后我对自己写的读写挂进行了读写测试.读写挂使用getchar(void)和putchar(int _Ch)函数进行读写,这两个函数的工作速度更快,但是一次只能对一个字符进行读或写.同样从文件中读入,立刻输出至标准输出,但这次的运行时间被输出至了标准输出.虽然不甚科学,但不会对数据产生太大的影响. 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;ctime&gt;inline void get_int(int&amp; a)&#123; char c=getchar(); bool flag=0; while(c!='-' &amp;&amp; (c&lt;'0' || c&gt;'9')) c=getchar(); if(c=='-') &#123; flag=1; c=getchar(); &#125; a=0; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123; a*=10; a+=c-'0'; c=getchar(); &#125; a=flag?-a:a; return;&#125;void put_int(int a)&#123; if(a&lt;0) &#123; putchar('-'); a=-a; &#125; if(a&gt;9) put_int(a/10); putchar('0'+a%10); return;&#125;inline void end_line(void)&#123;putchar('\n');&#125;inline void put_char(const char a[])&#123; for(int i=0;a[i]!='\0';i++) putchar(a[i]); return;&#125;int main()&#123; freopen("data.in","r",stdin); int tmp; double time0=clock(); for(int i=1;i&lt;=1000000;i++) &#123; get_int(tmp); put_int(tmp); putchar(' '); &#125; put_char("Cost "); put_int((int)((clock()-time0)/CLOCKS_PER_SEC*1000)); put_char("ms.\n"); return 0;&#125; 测试结果是这样的: Cost 142303ms. 共花费了142303毫秒,约142秒,超过2分钟. 对比&amp;总结最终得到的时间数据告诉我们,实际上的速度是这样的: v(scanf,printf)&lt;v(读写挂)&lt;v(cin,cout)&lt;v(cin,cout(关闭流同步)) 不禁开始怀疑人生.现在还没有找到问题所在,或许是我的读写挂太丑了?我查找了其他人写的读写挂,大部分和我的大同小异,应该没有太大影响. 等找到问题所在再来更新这篇文章吧.如果您有什么高见,请务必留下评论,感谢!本蒟蒻在此鞠躬.]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>胡言乱语</tag>
        <tag>奇技淫巧</tag>
        <tag>实验</tag>
        <tag>读写优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树链剖分学习笔记]]></title>
    <url>%2F2018%2F03%2F25%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前些日子在洛谷上写LCA的时候用倍增算法被卡常数了,一气之下就去查了其他的LCA算法,看到tarjan和树剖都能解决这个问题,于是就选择了学习树剖这条(不归之)路. 以上全是废话 我看了很多大犇的博客才终于大概搞明白了树链剖分是个什么逻辑和思路.虽然大犇们写的都很详细了,但对于本蒟蒻来说还是有些不那么容易理解,因此在这里尝试自己重新解释一下树链剖分的思想和具体实现,同时添加一些自己的理解,来帮助理解这个实际上并不困难的算法. 树链剖分的基本思想树链剖分或许更应该被称作一种思想,就是将一棵树拆分成几个部分,使每个部分内的元素之间都具有一定的联系,从而允许我们对进行过剖分的树利用一些其他的高级数据结构进行一些难以暴力解决的操作,如: 将节点x到节点y的最短路径上的所有节点/边的权值加某个值 将以节点x为根的子树中的所有节点/边的权值加某个值 查询节点x到节点y的最短路径上的所有节点/边的权值之和 查询以节点x为根的子树中的所有节点/边的权值之和 (还可以顺便求最近公共祖先LCA) 也就是说,树链剖分就如同它的名字一样,就是将树解剖成若干个部分(称为树链),方便后续的操作. 前置知识需求在学习树链剖分之前,需要先行掌握如下的知识: 树的基本概念 图的基本概念 深度优先搜索(DFS) 线段树(或者树状数组) 基本概念为了完成分解,需要计算几个辅助数组的值.首先定义一些概念(在概念名后面的括号内的是数组名): 和普通树相同的概念(不详细解释了) 父节点(f) 子节点(head) 大小(size) 深度(dep) 额外添加的概念 重子节点(hson):节点的子节点中具有最大的size的一个(这类节点又称为重节点.特别的,根节点是重节点) 轻子节点:除重子节点以外的所有节点(这类节点又称为轻节点) 重边:连接父节点和重子节点的边 轻边:连接父节点和轻子节点的边(除重边的所有边) 重链:若干重边连接成的链(下文中也会称为树链) 轻链:若干轻边连接成的链 链顶(top):该节点所在的重链的顶端节点的序号(请注意,这里的序号与下文将出现的编号有所不同.序号是节点的原始编号,而编号的具体意义将在下文解释.) 为了确认自己是不是已经理解了这些概念,这里附上一张图,并给出某些数组在这种情况下的值.其中,重节点将在图中以红色标识,重边以粗线标识,轻边以细线标识. 表格似乎生成的有些问题,正在寻找解决方法,先用图片代替了. 值得注意的是,我们所有下标均从1开始,并以0表示不存在. 如果对于任意节点,我们在访问完后优先访问它的重子节点,并将所有节点按照访问顺序编号,将得到这样的一组编号: 仔细观察这两张图以及表格,能够发现如下性质: 两个节点x,y在同一条重链上,当且仅当top[x]==top[y] 任何一条重链上的点编号连续 以任何一个点为根的子树中的所有点编号连续 事实上,这就是树剖得以解决问题的根本.因此,我们引入了一个新值编号(id):从根节点开始,对于任意节点,先访问其重子节点,然后再访问其其他节点所得到的某节点的访问次序编号.正是id具有的连续性,使得我们能够用线段树完成一些操作. 如何使用树剖的结果在研究树剖的实现之前,先来看看在树剖完成后如何应用其结果.我们由简到繁的讨论如下几个应用: 将以节点x为根的子树中的所有节点/边的权值加某个值我们假设已经实现了一棵线段树,其名称为t(一下应用中均包含此假设). 关于线段树的具体实现请看完整代码或是我关于线段树的学习笔记(暂时还没有). 显然,由于以任何一个点为根的子树中的所有点编号连续,这时只需要对以x的编号为起始点,x子树中编号最大的节点的编号为终止点的区间进行区间修改,就可以完成这个操作了.而由于连续,最大的点的编号就是x编号加上x的大小.因此,修改的区间就是$[id[x],id[x]+size[x])$. 查询以节点x为根的子树中的所有节点/边的权值之和同理,只需要对区间进行区间求和就可以完成了,同样是线段树的基本操作.操作区间同样是$[id[x],id[x]+size[x])$. 求两个节点x和y的最近公共祖先(LCA)显然,两个节点之间的最短路径会经过两个节点的最近公共祖先.因此,在研究对两点间最短路径上的操作之前,我们先来看看如何用树链剖分得到的数据求LCA. 显然,如果两个节点在同一条树链上,它们的LCA就是两点中深度较小的节点.这时可以直接得到结果:LCA=dep[x]&gt;dep[y]?y:x.而当两个节点不在同一树链上时,我们就可以利用top迅速的向上跳跃,来到另一条树链上,尽快的使两个节点到达同一条树链上.这也就解释了为什么我们的原则是”对于任意节点,先访问其重子节点,然后再访问其其他节点”:size的大小可以在一定程度上反映这棵子树的高度,将高度最大的一条作为重链可以使这上面的点迅速跳到顶端,减少跳跃次数,提高算法的效率. 需要注意的是,我们应该让跳跃后到达的链顶深度更大的点跳跃而另一个点保持不动.这样才能保证两个点不会擦肩而过. 比如这个例子中,我们若要求点11和12的LCA,我们若首先让11向上跳跃将到达2,而事实上11和12的LCA是6,这时已经不可能再得到正确的结果了. 代码也不难写出: 123456789int lca(int x,int y) &#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=f[top[x]];//注意这里,top[x]和x仍在同一树链上,要到达另外一条树链需要取top[x]的父节点 &#125; return dep[x]&gt;dep[y]?y:x;&#125; 代码很简单,但是已经足够正确的求解LCA问题了. 将节点x到节点y的最短路径上的所有节点/边的权值加某个值我们采用和上面求LCA一样的思路:不断使两个节点向上移动从而逼近,直到两个节点到达同一树链,这时即可一步完成最后一段的操作. 不难想到,为了实现这个操作,我们只需要在每一步移动x点的时候,修改移动经过的点的权值,就可以轻松完成任务了.由于”任何一条重链上的点编号连续”,我们的区间也很好确定:两点在同一条树链上时,操作区间为$[min(id[x],id[y]),max(id[x],id[y])]$;每次移动x点的时候,操作区间为$[id[top[x]],id[x]]$(注意这里左边界不是$id[f[top[x]]]$,因为这个点将在下次被计算) 代码只需要在LCA代码的基础上稍加修改就可以了: 123456789101112void mod_path(int x,int y,int v)&#123; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); t.add(id[top[x]],id[x]+1,v);//由于个人习惯,我的线段树操作区间是左闭右开区间,因此+1 //实际的方法参数会更多,这里忽略了次要矛盾,只突出了主要矛盾:操作区间和增加的值 x=f[top[x]]; &#125; t.add(min(id[x],id[y]),max(id[x],id[y])+1,v); return;&#125; 同样是很简洁的代码,依然轻松的完成了任务. 查询节点x到节点y的最短路径上的所有节点/边的权值之和思路完全同上,只是将方法从修改变为区间求和,设置一个临时变量累加,最后返回. 注意:如果有要求千万不要忘记取余,否则请估计结果大小开足够大的变量避免溢出. 代码只需要简单修改上面的片段就可以了. 123456789101112int cal_path(int x,int y)&#123; int ans=0; while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); ans+=t.cal(id[top[x]],id[x]+1); x=f[top[x]]; &#125; ans+=t.cal(min(id[x],id[y]),max(id[x],id[y])+1); return ans;&#125; 依旧简洁. 如何进行树剖现在,我们已经看到了树剖所得到的结果能够正确的工作,帮助我们高效的完成之前提到的几种操作.现在,是时候考虑如何计算这些辅助数组的值了.我们同样分为几步考虑. 输入/建树一般来讲,树的输入有两种:给出所有边的信息以及根节点的序号,或是给出根节点序号和f数组.无论对于哪一种情况,我们需要进行一次DFS.在这次DFS中,我们可以完成对f,size,dep,hson和head数组的初始化. 我们从根节点开始,对于每一个访问到的节点(记为t),标记t为已访问,将所有与其有边相连的未访问节点(记为to)的父节点设为t(若是第二种情况则可以省略这一步),并将to加入t的head集合中,更新to的dep的值,然后递归的以to为当前节点,继续操作,并在回溯时更新t的size和hson的值.下面是代码,更详细的解释将在代码中以注释的形式进行. 1234567891011121314151617181920212223void link_constructor(int t)&#123; a[t].size=1;//以当前节点为根的子树中目前只已知1个节点 visited[t]=1;//标记为已访问防止重复访问(死循环) //这里使用了链表,其细节将在下文出现 edge* tar=temp[t];//temp用于临时存储边(适用于第一种情况),在输入时完成初始化 while(tar!=NULL)//直到不再有与当前节点有边相连的节点为止 &#123; edge* tt=tar-&gt;next;//由于之后可能会修改tar指向的结构体中的next指针,预先存储其指向的地址 if(!visited[tar-&gt;to]) &#123; a[tar-&gt;to].f=t;//设置父节点 a[tar-&gt;to].dep=a[t].dep+1;//设置深度:比父节点深1层 link_constructor(tar-&gt;to);//递归调用,先完成子节点的构建,以便更新当前节点的值 if(a[t].hson==0 || a[a[t].hson].size&lt;a[tar-&gt;to].size) a[t].hson=tar-&gt;id;//若当前节点还没有重子节点或是重子节点不够重,进行更新 a[t].size+=a[tar-&gt;to].size;//更新当前节点的size,加上以子节点作为根的子树的size tar-&gt;next=a[t].head; a[t].head=tar;//将子节点加入集合 &#125; tar=tt;//查看下一个与当前节点有边相连的节点 &#125; return;&#125; 代码同样不长,现在,我们已经完成了f,size,dep,hson的计算,并删除了重边,完成了所有节点的子节点集合. 分割树虽然我们首先进行了一次DFS,但是不幸的是,由于不能预先确定重子节点,我们并不能在这一次DFS中确定重链,也不能给节点编号.因此我们再进行一次DFS.在这一次DFS中,我们就可以利用上一次DFS中得到的重子节点的数据给节点依照我们规定的原则编号,并确定重链,初始化每个节点的top值.同样,更详细的将在代码中说明. 12345678910111213141516171819202122int Index=0;//用于编号void split_constructor(int t)&#123; //有关初始化的细节将在下文出现 id[t]=++Index;//编号 if(hson[t])//如果有重子节点 &#123; top[hson[t]]=top[t];//显然重子节点和其父节点在同一条树链上,拥有共同的链顶 split_constructor(hson[t]);//优先访问重子节点 &#125; edge* tar=head[t]; while(tar!=NULL) &#123; if(tar-&gt;to!=hson[t])//注意不能重复访问节点 &#123; top[tar-&gt;to]=tar-to;//与父节点不在同一树链上,自己作为自己所在的树链的链顶 split_constructor(tar-&gt;to); &#125; tar=tar-&gt;next; &#125; return;&#125; 在这一次DFS中,我们按照之前确定的顺序,利用上一次DFS得到的信息,成功的将节点进行了编号,并且确定了各个节点的top值.这样就完成了对树的分割. 初始化线段树最终的操作要有线段树完成,因此还要完成对线段树的初始化.由于所有操作的区间均由节点的编号决定,因此用于构造线段树的数组的下标将与节点编号对应.我们采用一种简单而直观的方法完成(或许并不优美): 123456int tempval[MAX];//临时数组,MAX是最大节点数void sgtree_constructor(int n)//一共n个节点&#123; for(int i=1;i&lt;=n;i++) tempval[id[i]]=val[i];//将序号为i的节点的权值存储在临时数组下标为i的编号的位置 t.build(tempval,1,n+1);//调用线段树方法进行构造&#125; 这样,线段树也构造好了. 至此,各个部分均已完成,下面就只需要将这些部分串联在一起了. 总初始化函数只要按照逻辑,依次执行第一次DFS,第二次DFS,线段树初始化就可以了. 12345678910void constructor(int n,int r)&#123; f[r]=0;//根节点没有父节点 dep[r]=1;//根节点深度为1 link_constructor(r);//第一次DFS top[r]=r;//根节点是自己所在的树链的链顶 split_constructor(r);//第二次DFS sgtree_constructor(n);//初始化线段树 return;&#125; 至此,所有初始化已经完成,下面只需要正确的定义变量,正确的完成主函数的逻辑,按照要求处理输入的数据和指令并正确输出就可以了.下面,我们在实际问题中进行尝试. 例题P3178 [HAOI2015]树上操作事实上在洛谷是有树链剖分的模板题的,但是首先让我们从这个更简单一点的模板题开始吧(洛谷的模板题比这个要难).这道题是一个纯粹的树剖,没有任何技巧,甚至不需要进行两个点的向上移动操作(一股清流),纯粹是练习逻辑的.那么直接上就好了,像我这样写代码奇丑的人代码量都还算可以. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=100010;template&lt;typename T&gt;struct sgtree&#123; private: T tree[MAX&lt;&lt;2]; T change[MAX&lt;&lt;2]; void updata(int t) &#123; tree[t]=tree[t&lt;&lt;1]+tree[t&lt;&lt;1|1]; return; &#125; void pushdown(int t,int l,int r) &#123; if(!change[t]) return; int t1=t&lt;&lt;1; int t2=t&lt;&lt;1|1; int m=(l+r)&gt;&gt;1; tree[t1]+=change[t]*(m-l); tree[t2]+=change[t]*(r-m); change[t1]+=change[t]; change[t2]+=change[t]; change[t]=0; return; &#125; public: void build(T a[],int l,int r,int t) &#123; if(l==r-1) tree[t]=a[l]; else&#123; int m=(l+r)&gt;&gt;1; build(a,l,m,t&lt;&lt;1); build(a,m,r,t&lt;&lt;1|1); updata(t); &#125; return; &#125; void add(int t,int l,int r,int low,int high,T v) &#123; if(low&lt;=l &amp;&amp; r&lt;=high)&#123; tree[t]+=v*(r-l); change[t]+=v; &#125;else&#123; pushdown(t,l,r); int m=(l+r)&gt;&gt;1; if(low&lt;m) add(t&lt;&lt;1,l,m,low,high,v); if(m&lt;high) add(t&lt;&lt;1|1,m,r,low,high,v); updata(t); &#125; return; &#125; T cal(int t,int l,int r,int low,int high) &#123; if(low&lt;=l &amp;&amp; r&lt;=high) return tree[t]; pushdown(t,l,r); int m=(l+r)&gt;&gt;1; T ans=0; if(low&lt;m) ans+=cal(t&lt;&lt;1,l,m,low,high); if(m&lt;high) ans+=cal(t&lt;&lt;1|1,m,r,low,high); return ans; &#125;&#125;;sgtree&lt;long long&gt; sgt;struct edge&#123; int to; edge* next; edge() &#123; to=0; next=NULL; &#125;&#125;;edge e[MAX&lt;&lt;1];int n;long long val[MAX];long long tempval[MAX];int f[MAX];int top[MAX];int id[MAX];int dep[MAX];int hson[MAX];int size[MAX];bool visited[MAX];edge* temp[MAX];edge* head[MAX];int Index=0;int coun=0;void add_edge(int x,int y)&#123; e[coun].to=y; e[coun].next=temp[x]; temp[x]=&amp;e[coun++]; return;&#125;void tree_con(int t)&#123; visited[t]=1; size[t]=1; edge* tar=temp[t]; while(tar!=NULL) &#123; edge* n=tar-&gt;next; int&amp; to=tar-&gt;to; if(!visited[to]) &#123; f[to]=t; dep[to]=dep[t]+1; tree_con(to); if(!hson[t] || size[hson[t]]&lt;size[to]) hson[t]=to; size[t]+=size[to]; tar-&gt;next=head[t]; head[t]=tar; &#125; tar=n; &#125; return;&#125;void split_con(int t)&#123; id[t]=++Index; if(hson[t]) &#123; top[hson[t]]=top[t]; split_con(hson[t]); &#125; edge* tar=head[t]; while(tar!=NULL) &#123; int&amp; to=tar-&gt;to; if(to!=hson[t]) &#123; top[to]=to; split_con(to); &#125; tar=tar-&gt;next; &#125; return;&#125;void sgtree_con(void)&#123; for(int i=1;i&lt;=n;i++) tempval[id[i]]=val[i]; sgt.build(tempval,1,n+1,1); return;&#125;void constructor(int r)&#123; tree_con(r); top[r]=r; split_con(r); sgtree_con(); return;&#125;long long cal_path(int x)&#123; long long ans=0; while(top[x]!=1) &#123; ans+=sgt.cal(1,1,n+1,id[top[x]],id[x]+1); x=f[top[x]]; &#125; ans+=sgt.cal(1,1,n+1,1,id[x]+1); return ans;&#125;int main()&#123; int m,x,y,flag; long long a; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%lld",val+i); for(int i=1;i&lt;n;i++) &#123; scanf("%d%d",&amp;x,&amp;y); add_edge(x,y); add_edge(y,x); &#125; constructor(1); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;flag,&amp;x); if(flag==1)&#123; scanf("%lld",&amp;a); sgt.add(1,1,n+1,id[x],id[x]+1,a); &#125;else if(flag==2)&#123; scanf("%lld",&amp;a); sgt.add(1,1,n+1,id[x],id[x]+size[x],a); &#125;else if(flag==3)&#123; printf("%lld\n",cal_path(x)); &#125; &#125; return 0;&#125; P3379 【模板】最近公共祖先（LCA）是的,是时候报复这道题了!之前能卡我的常数,看看这回用新的方法它还能不能卡住我! 这同样是树链剖分的删减版,虽然需要进行两点上移的操作,但是由于不需要计算权值,我们不需要构造线段树,也不需要为节点编号,只需要正确的top数组就可以AC这道题.因此,代码同样不长(虽然不长,但看起来依然很丑). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=500010;struct edge&#123; int to; edge* next; edge() &#123; to=0; next=NULL; &#125;&#125;;edge e[MAX&lt;&lt;1];edge* temp[MAX];edge* head[MAX];int f[MAX];int next[MAX];int size[MAX];int dep[MAX];int top[MAX];int id[MAX];bool visited[MAX];int ecount=0;void dfs(int t)&#123; size[t]=1; next[t]=0; edge* tar=temp[t]; while(tar!=NULL) &#123; edge* nn=tar-&gt;next; if(!visited[tar-&gt;to]) &#123; dep[tar-&gt;to]=dep[t]+1; visited[tar-&gt;to]=1; f[tar-&gt;to]=t; dfs(tar-&gt;to); size[t]+=size[tar-&gt;to]; if(!next[t] || size[next[t]]&lt;size[tar-&gt;to]) next[t]=tar-&gt;to; tar-&gt;next=head[t]; head[t]=tar; &#125; tar=nn; &#125; return;&#125;void split(int t)&#123; if(next[t]!=0) &#123; id[next[t]]=++ecount; top[next[t]]=top[t]; split(next[t]); &#125; edge* tar=head[t]; while(tar!=NULL) &#123; if(tar-&gt;to!=next[t]) &#123; id[tar-&gt;to]=++ecount; top[tar-&gt;to]=tar-&gt;to; split(tar-&gt;to); &#125; tar=tar-&gt;next; &#125; return;&#125;void build_tree(int s)&#123; dep[s]=1; visited[s]=1; f[s]=0; dfs(s); return;&#125;void init_split(int s)&#123; id[s]=0; top[s]=s; split(s);&#125;void total_init(int s)&#123; build_tree(s); init_split(s); return;&#125;int lca(int a,int b)&#123; while(top[a]!=top[b]) &#123; if(dep[top[a]]&lt;dep[top[b]]) swap(a,b); a=f[top[a]]; &#125; return dep[a]&gt;dep[b]?b:a;&#125;int main()&#123; int n,x,y,s,m; scanf("%d%d%d",&amp;n,&amp;m,&amp;s); for(int i=0;i&lt;n-1;i++) &#123; scanf("%d%d",&amp;x,&amp;y); e[i&lt;&lt;1].to=y; e[i&lt;&lt;1].next=temp[x]; temp[x]=&amp;e[i&lt;&lt;1]; e[i&lt;&lt;1|1].to=x; e[i&lt;&lt;1|1].next=temp[y]; temp[y]=&amp;e[i&lt;&lt;1|1]; &#125; total_init(s); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",lca(x,y)); &#125; return 0;&#125; 这样就不会再被这道题卡常数了(虽然和没有使用vector有关,但实际上这种方法依然比使用了同样存储方式的倍增快近300ms). P3384 【模板】树链剖分终于来到了这里.我们已经在之前的两道例题中分别测试了树剖算法的一部分功能,而现在我们要将所有功能组合在一起,用完整版的树剖A掉这道题(“A上去就赢啦!”). 其实依然很简单,只要将所有功能放进去,写好主函数就已经成功了.(因为代码量变大了,所以代码更丑了) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=100010;int count_edge=0;int Index=0;int n,pp;bool visited[MAX];template&lt;typename T&gt;struct sgtree&#123; private: T tree[MAX&lt;&lt;2]; T change[MAX&lt;&lt;2]; T p; void updata(int t) &#123; tree[t]=(tree[t&lt;&lt;1]+tree[t&lt;&lt;1|1])%p; return; &#125; void pushdown(int t,int l,int r) &#123; if(!change[t]) return; int t1=t&lt;&lt;1; int t2=t&lt;&lt;1|1; int m=(l+r)&gt;&gt;1; tree[t1]=(tree[t1]+change[t]*(m-l))%p; tree[t2]=(tree[t2]+change[t]*(r-m))%p; change[t1]=(change[t1]+change[t])%p; change[t2]=(change[t2]+change[t])%p; change[t]=0; return; &#125; public: void init(T mo) &#123; p=mo; return; &#125; void build(T a[],int l,int r,int t) &#123; if(l==r-1) tree[t]=a[l]%p; else&#123; int m=(l+r)&gt;&gt;1; build(a,l,m,t&lt;&lt;1); build(a,m,r,t&lt;&lt;1|1); updata(t); &#125; return; &#125; void add(int t,int l,int r,int low,int high,T v) &#123; if(low&lt;=l &amp;&amp; r&lt;=high)&#123; tree[t]=(tree[t]+v*(r-l))%p; change[t]=(change[t]+v)%p; &#125;else&#123; pushdown(t,l,r); int m=(l+r)&gt;&gt;1; if(low&lt;m) add(t&lt;&lt;1,l,m,low,high,v); if(m&lt;high) add(t&lt;&lt;1|1,m,r,low,high,v); updata(t); &#125; return; &#125; T cal(int t,int l,int r,int low,int high) &#123; if(low&lt;=l &amp;&amp; r&lt;=high) return tree[t]%p; pushdown(t,l,r); int m=(l+r)&gt;&gt;1; T ans=0; if(low&lt;m) ans+=cal(t&lt;&lt;1,l,m,low,high); if(m&lt;high) ans+=cal(t&lt;&lt;1|1,m,r,low,high); return ans; &#125;&#125;;sgtree&lt;int&gt; sgt;struct edge&#123; int id; edge* next; edge() &#123; id=0; next=NULL; &#125;&#125;e[MAX&lt;&lt;1];edge* temp[MAX];struct node&#123; int id; int f; int hson; int val; int top; int dep; int size; edge* head; node() &#123; id=0; f=0; hson=0; val=0; top=0; dep=0; size=0; head=NULL; &#125;&#125;a[MAX];int tempval[MAX];void link_constructor(int t)&#123; a[t].size=1; visited[t]=1; edge* tar=temp[t]; while(tar!=NULL) &#123; edge* tt=tar-&gt;next; if(!visited[tar-&gt;id]) &#123; a[tar-&gt;id].f=t; a[tar-&gt;id].dep=a[t].dep+1; link_constructor(tar-&gt;id); if(a[t].hson==0 || a[a[t].hson].size&lt;a[tar-&gt;id].size) a[t].hson=tar-&gt;id; a[t].size+=a[tar-&gt;id].size; tar-&gt;next=a[t].head; a[t].head=tar; &#125; tar=tt; &#125; return;&#125;void split_constructor(int t)&#123; a[t].id=++Index; if(a[t].hson) &#123; a[a[t].hson].top=a[t].top; split_constructor(a[t].hson); &#125; edge* tar=a[t].head; while(tar!=NULL) &#123; if(tar-&gt;id!=a[t].hson) &#123; a[tar-&gt;id].top=tar-&gt;id; split_constructor(tar-&gt;id); &#125; tar=tar-&gt;next; &#125; return;&#125;void sgtree_constructor(int p)&#123; sgt.init(p); for(int i=1;i&lt;=n;i++) tempval[a[i].id]=a[i].val; sgt.build(tempval,1,n+1,1); return;&#125;void major_constructor(int r,int p)&#123; a[r].dep=1; link_constructor(r); a[r].top=r; split_constructor(r); sgtree_constructor(p); return;&#125;void mod_xtoy(int x,int y,int v)&#123; while(a[x].top!=a[y].top) &#123; if(a[a[x].top].dep&lt;a[a[y].top].dep) swap(x,y); sgt.add(1,1,n+1,a[a[x].top].id,a[x].id+1,v); x=a[a[x].top].f; &#125; sgt.add(1,1,n+1,min(a[x].id,a[y].id),max(a[x].id,a[y].id)+1,v); return;&#125;int cal_xtoy(int x,int y)&#123; int ans=0; while(a[x].top!=a[y].top) &#123; if(a[a[x].top].dep&lt;a[a[y].top].dep) swap(x,y); ans=(ans+sgt.cal(1,1,n+1,a[a[x].top].id,a[x].id+1))%pp; x=a[a[x].top].f; &#125; ans=(ans+sgt.cal(1,1,n+1,min(a[x].id,a[y].id),max(a[x].id,a[y].id)+1))%pp; return ans;&#125;int main()&#123; int m,r,x,y; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;r,&amp;pp); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i].val); for(int i=1;i&lt;n;i++) &#123; scanf("%d%d",&amp;x,&amp;y); e[count_edge].id=y; e[count_edge].next=temp[x]; temp[x]=&amp;e[count_edge++]; e[count_edge].id=x; e[count_edge].next=temp[y]; temp[y]=&amp;e[count_edge++]; &#125; major_constructor(r,pp); int flag,z; for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;flag,&amp;x); if(flag==4) printf("%d\n",sgt.cal(1,1,n+1,a[x].id,a[x].id+a[x].size)%pp); else if(flag==3)&#123; scanf("%d",&amp;z); sgt.add(1,1,n+1,a[x].id,a[x].id+a[x].size,z); &#125;else if(flag==2)&#123; scanf("%d",&amp;y); printf("%d\n",cal_xtoy(x,y)%pp); &#125;else&#123; scanf("%d%d",&amp;y,&amp;z); mod_xtoy(x,y,z); &#125; &#125; return 0;&#125; A掉了这道题,就可以说是掌握了树剖的一些皮毛了.下面,再去洛谷寻找带有树链剖分标签的题,开始虐题(被题虐)吧. 后记其实树链剖分本身并没有很难.它的逻辑很清晰,过程也极其简单:DFS1,DFS2,再写好线段树,基本就完成了.而难的地方是它衍生出来的花样.如果能够正确的看出来哪里可以用树剖解决,剩下的问题就好解决了. 我是一棵蒟蒻,如果有幸有大犇路过发现我哪里理解的不对,出现了偏差,还请大犇使劲的喷,那也是对我的帮助.谢谢.]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>树</tag>
        <tag>树算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈并查集]]></title>
    <url>%2F2018%2F03%2F25%2F%E6%B5%85%E8%B0%88%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[最近在洛谷上看到了一道水题,是NOI2002的第一题,银河英雄传说.一看上去就是个并查集,感觉很简单的样子(心想:没想到NOI还有这么水的题!),结果一做才知道:逻辑想的挺好,实际上就是WA.在交了好几次WA之后,仔细把自己的逻辑重新整理了几遍,终于发现了问题所在,于是A掉了这道题.(明明我的逻辑基本上一点问题都没有,就是忽略了一个赋值的先后带来的影响!) 感觉自己还是没有真正掌握并查集的皮毛(好伤心),于是打算总结一下并查集,争取能温故知新. 并查集的意义(需求)标准的并查集是为了高效的进行一系列的如下操作: 将x和y所在的集合合并为一个集合 查询x与y是否存在于同一集合 其中由于是集合的合并,因此我们需要重新将集合中的所有元素放入新的集合.而并查集就是为了高效的实现这些操作. 并查集的基本思想我们采用一个标记值,具有相同的标记值的元素将被认为是存在于同一集合中.理论上这个标记值是任意的,但为了方便,我们常常将集合中的某个元素作为标记值. 前置知识需求为了理解并查集,需要现行学习以下的知识: 数组的基本操作 树的基本概念 递归算法 结构体 链表 并查集的初级实现并查集的数组实现显然,可以用一个一位数组(称之为f)完成所需要进行的操作.元素x与y在同一个集合当且仅当f[x]==f[y].代码很简单. 1234567891011121314151617181920const int MAX=10010;int f[MAX];int n;//假设n中已经存储了当前的总元素数void init(void)//初始化&#123; for(int i=1;i&lt;=n;i++) f[i]=i;//开始任何两个元素都不在同一集合中 return;&#125;void join(int x,int y)//合并&#123; if(f[x]==f[y]) return;//不必检查已经合并的,可以节省一定的时间(没啥用) int tmp=f[x]; for(int i=1;i&lt;=n;i++) if(f[i]==tmp) f[i]=f[y];//调整所有的与x在同一集合中的元素的标记值使其与y中元素的标记值相同,从而表示它们被合并进了进入y所在的集合 return;&#125;bool check(int x,int y)//检查x与y是否在同一个集合中&#123; return f[x]==f[y];&#125; 显然,这个方法是正确的.我们可以尝试通过洛谷的并查集模板题(记得看清数组要开多大).完整的代码像下面这样(如同以前一样,我会省略一切之前出现过的解释文字): 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;using namespace std;const int MAX=10010;int f[MAX];int n;void init(void)&#123; for(int i=1;i&lt;=n;i++) f[i]=i; return;&#125;void join(int x,int y)&#123; if(f[x]==f[y]) return; int tmp=f[x]; for(int i=1;i&lt;=n;i++) if(f[i]==tmp) f[i]=f[y]; return;&#125;bool check(int x,int y)&#123; return f[x]==f[y];&#125;int main()&#123; int m,flag,x,y; scanf("%d%d",&amp;n,&amp;m); init(); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;flag,&amp;x,&amp;y); if(flag==1) join(x,y); else if(check(x,y)) printf("Y\n"); else printf("N\n"); &#125; return 0;&#125; umm…AC了(和我的计划有些出入).好吧,我们来这里进行尝试:259. 亲戚. 仔细读题,发现这也是一个单纯的并查集.因此,按照题目的输入格式修改一下代码(请注意,这里使用的是文件读写),比赛中是没有优化的,因此我们选择 “无优化开关”(一定要选…不然…). umm…TLE了(强行). 我们来胡乱分析一波时间复杂度.对于n个元素m次操作,假设合并和查询随机出现,而合并时间复杂度为$O(n)$,查询为$O(1)$,平均时间复杂度近似为$O(nm)$,显然太慢,因此会超时. 我们来思考另一种思路:之前的方法中时间主要浪费在合并时遍历f数组.我们想到使用链表,将同一集合的元素链在一起,那么我们修改时只需要遍历一遍其中一条链,再将两条链拼接在一起,而不会访问无意义的数据,显然提高了效率.按照这个思路,我们获得了并查集的另一种初级实现. 并查集的链表实现我们定义一个结构体,将元素的信息存储进去,然后定义一个结构体数组表示元素,命名为a,像这样: 123456789101112131415const int MAX=10010;struct ele&#123; ele* f;//指向下标为当前元素的标记值的元素的指针 ele* next;//指向链表中下一个元素的指针 ele* ends;//指向链表末尾的指针 ele()//构造函数,用于初始化 &#123; f=this;//各自为一个集合,自己的下标就是自己的标记值 next=NULL;//链表只有当前一个元素,没有下一个元素 ends=this;//链表末尾就是自己 &#125;&#125;;ele a[MAX]; 我们在检查x和y是否在同一个集合中的时候,同样仅需检查它们的f是否相同,也就是x与y在同一集合,当且仅当a[x].f==a[y].f.写成函数: 1234bool check(int x,int y)&#123; return a[x].f==a[y].f;&#125; 而合并时,我们需要遍历一遍其中一条链(链x),修改其上的所有元素的f.为了方便和直观起见,我们选用链表头元素的下标作为标记值.那么,我们就只需要在遍历并修改f之后,修改另一条链(链y)的尾的next值使其指向链x,那么链x就被连接到了链y之后,依然满足我们的约定.代码: 123456789101112void join(int x,int y)&#123; if(check(x,y)) return;//已经在同一集合中,不必合并 ele* tar=a[x].f;//当前元素 ele* head=tar;//保存原链的头(其实修改一下下面的代码就可以省下这一个空间,但我懒得改了) while(tar!=NULL)//直到移出了链表 &#123; tar-&gt;f=a[y].f;//修改f值 tar=tar-&gt;next;//向后移动 &#125; a[y].f-&gt;ends-&gt;next=head;//将两条链连接&#125; 这样就完成了并查集的链表实现.我们再次尝试去解决259. 亲戚.完善之后的完整代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;using namespace std;const int MAX=20010;struct ele&#123; ele* f; ele* next; ele* ends; ele() &#123; f=this; next=NULL; ends=this; &#125;&#125;;ele a[MAX];bool check(int x,int y)&#123; return a[x].f==a[y].f;&#125;void join(int x,int y)&#123; if(check(x,y)) return; ele* tar=a[x].f; ele* head=tar; while(tar!=NULL) &#123; tar-&gt;f=a[y].f; tar=tar-&gt;next; &#125; a[y].f-&gt;ends-&gt;next=head;&#125;int main()&#123; freopen("relations.in","r",stdin);//文件读 freopen("relations.out","w",stdout);//文件写 int n,m,x,y,q; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); join(x,y); &#125; scanf("%d",&amp;q); for(int i=1;i&lt;=q;i++) &#123; scanf("%d%d",&amp;x,&amp;y); if(check(x,y)) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; 依然选择无优化开关,这次成功的A掉了这道题. 但是仔细观察数据,我们注意到有好几个点是900多毫秒通过的,在超时的边缘试探.看来还是不行.我们再来分析. 这个方法中的时间主要仍是遍历一遍链表.我们注意到虽然操作两条链表,但需要遍历的只有一条.自然想到,我们应该尽量的去遍历更短的那一条,这样会花费更少的时间.如何确定那一条更短呢?我们可以在结构体中添加一个变量size,表示以该元素为表头的链表的长度.显然,合并将使链表的长度变为两链原长之和,而我们只须修改表头元素的信息即可,不会花费过多的额外时间.而初始化也很简单:只有一个元素的链表长度自然为1. 而在合并时,我们只需要判断一下,选择遍历更短的链表即可.修改后的代码只加上了为数不多的几条语句: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;using namespace std;const int MAX=20010;struct ele&#123; ele* f; ele* next; ele* ends; int size;//定义size ele() &#123; f=this; next=NULL; ends=this; size=1;//初始化size &#125;&#125;;ele a[MAX];bool check(int x,int y)&#123; return a[x].f==a[y].f;&#125;void join(int x,int y)&#123; if(check(x,y)) return; if(a[x].f-&gt;size&gt;a[y].f-&gt;size) x^=y^=x^=y;//如果x链的长度更长,交换x和y的值,使得这行执行后x所在的链是更短的链 ele* tar=a[x].f; ele* head=tar; while(tar!=NULL) &#123; tar-&gt;f=a[y].f; tar=tar-&gt;next; &#125; a[y].f-&gt;ends-&gt;next=head; a[y].f-&gt;size+=head-&gt;size;//维护size的值&#125;int main()&#123; freopen("relations.in","r",stdin); freopen("relations.out","w",stdout); int n,m,x,y,q; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); join(x,y); &#125; scanf("%d",&amp;q); for(int i=1;i&lt;=q;i++) &#123; scanf("%d%d",&amp;x,&amp;y); if(check(x,y)) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; 再次尝试提交,在无优化开关的情况下,我们的优化成功使耗时最长的测试点从$912ms$优化到了$53ms$,而代码量只增加了4行,内存占用增加了$20kb$. 似乎到这里已经很优了.但事实上,我们还能做的更好.放松对于属于同一集合的元素标记值的限制,将给我们打开更广阔的空间.在下面的方法中,我们将不再限定属于同一集合的元素必须被相同的标记值标记.这将使我们的查找变慢,但将提高合并速度. 并查集的有根树实现现在我们重新定义一下我们的f数组: f[i]表示元素i在树上父亲是f[i]. 特殊的,对于没有父亲的节点(如x),我们令f[x]=x,并称这样的元素为其子树中任意元素的祖先. 现在,对于两个元素x和y,它们在同一集合中当且仅当x的祖先和y的祖先相同. 按照这些定义和约定,我们分不同的操作来看如何用这种方式实现并查集. 1.如何使用 同样的,在研究如何初始化(并操作)并查集之前,我们先假设已经完成了这些操作,来研究如何正确的进行查询. 假设我们现在被询问元素x与y是否存在于同一个集合中.按照我们之前给出的定义,我们应该分别寻找x和y的祖先,然后比较这两个祖先是否相同.而祖先(设为k)的标志是f[k]==k,那么我们就可以用一个while循环完成对祖先的查找;由于一次check中要进行两次查询,我们将查询写为函数可以减小代码量.按照我们的分析,可以写出如下的代码: 12345678910//略去了对数组的定义int find(int a)//寻找a的祖先&#123; while(f[a]!=a) a=f[a];//当f[a]!=a时,说明当前的a尚不是祖先,我们要继续向上寻找 return a;//此时一定有a==f[a],也就是说我们已经找到了祖先,就是当前的a,直接返回&#125;bool check(int x,int y)&#123; return find(x)==find(y);//将find写为函数之后check函数就无比简单了,直接比较以x和y为参数执行的find返回的祖先是否相同就可以了&#125; 可以像这样形象(但不一定准确)的理解这个过程:这是一个组织,有准确的领导关系:每个人会被另一个人领导(他的父亲),但同时他可以领导多个其他人(当然,也肯能只领导一个人或是谁也不领导).其中只有一个例外:有一个老大(祖先),他是老大,他说了算,我们可以认为是他领导自己.因此,f[r]==r(r表示根,祖先,这里的老大).现在这里有很多这样的组织. 有一天有两个人碰面了,他们想知道他们是不是在一个组织中,怎么办?只要看看他们是不是受同一个老大领导就好了. 于是两个人就分别去问他们的领导,咱们老大是谁啊?如果他们的领导不是自己领导自己,那么他就不是老大.那就让领导去问领导的领导,直到问到一个人,他自己领导自己,那么他就是老大.他告诉来问自己的人:我就是老大!于是那个人知道了,再回去告诉来问自己的人:xxx就是老大.于是就这样一路传达,直到最初提问的那个人,于是他就知道了自己的老大就是xxx. 两个人都知道了自己的老大是谁,那么只要看看老大是不是一个人就知道了. 2.如何完成合并 现在假设我们被要求将x所在的集合和y所在的集合合并为一个集合.这也就意味着x所在集合中的任何元素的祖先必须被设定为与y中元素的祖先相同(反过来也可以).显然,如果逐个修改和朴素方法是没有区别的,我们考虑一个牵一发而动全身的方法:只要将x所在集合的祖先的父亲设为y所在集合的祖先,那么我们查询时的循环将不会在x的原祖先处停止,而会查询到y的祖先,而原y所在集合中的元素的祖先不会发生变化. 这样,我们在合并时不再需要遍历,只需要找到两个集合的祖先并且使其中一个(k)成为另一个(l)的父亲,那k就成为了原来k和l的子树中的所有元素的共同祖先,而这只会让我们在查询时增加不超过1次.而我们发现这里又出现了寻找祖先的工作,同样交给我们的find函数. 按照我们的分析,代码同样不难写出: 123456789//省略掉find函数void join(int x,int y)&#123; int fx=find(x); int fy=find(y); if(fx==fy) return;//不进行无意义的合并 f[fx]=fy;//反过来,f[fy]=fx也可以,看个人喜好 return;&#125; 继续按上文的例子理解一下:现在x和y所在的组织被要求合并成一个组织了.怎么办?我们只能让其中的一个老大屈尊,被另一个老大领导,那么就成为一个组织了. 3.如何初始化 这是最简单的一步了.一开始任意两个元素都不在同一个集合中,那么各自都是自己的祖先(-_-||),只要让f[i]=i就可以了. 123456//省略n的定义并假设n中存储了总元素的量void init(void)&#123; for(int i=1;i&lt;=n;i++) f[i]=i; return;&#125; umm…各自为战,我一个人就是一个组织… 将之前的三部分中的所有函数组合在一起,定义数组f和变量n,我们就完成了并查集的初级实现,已经能正确的完成前面提到的操作了!为了美观和方便,我们将并查集写成一个结构体,将数组作为成员变量,并用private关键字保护,函数作为方法出现(由于没有直接查询祖先的需求,find函数将同样被加以保护): 12345678910111213141516171819202122232425262728293031323334const int MAX=10010;int n;struct uf&#123; private://一般不能从结构体以外访问到 int f[MAX]; int find(int a) &#123; while(f[a]!=a) a=f[a]; return a; &#125; public://允许从结构体外访问 void init(void) &#123; for(int i=1;i&lt;=n;i++) f[i]=i; return; &#125; bool check(int x,int y) &#123; return find(x)==find(y); &#125; void join(int x,int y) &#123; int fx=find(x); int fy=find(y); if(fx==fy) return; f[fx]=fy; return; &#125;&#125;; 完成了.可以正确的书写主函数,再去水一次259. 亲戚. 像这样: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;using namespace std;const int MAX=20010;int n;struct uf&#123; private: int f[MAX]; int find(int a) &#123; while(f[a]!=a) a=f[a]; return a; &#125; public: void init(void) &#123; for(int i=1;i&lt;=n;i++) f[i]=i; return; &#125; bool check(int x,int y) &#123; return find(x)==find(y); &#125; void join(int x,int y) &#123; int fx=find(x); int fy=find(y); if(fx==fy) return; f[fx]=fy; return; &#125;&#125;;uf f;int main()&#123; freopen("relations.in","r",stdin); freopen("relations.out","w",stdout); int m,x,y,q; scanf("%d%d",&amp;n,&amp;m); f.init(); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;x,&amp;y); f.join(x,y); &#125; scanf("%d",&amp;q); for(int i=1;i&lt;=q;i++) &#123; scanf("%d%d",&amp;x,&amp;y); if(f.check(x,y)) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; ummm…TLE…似乎受到欺骗,不是说我们能做的更好了吗? 没错,所以我们这是基本实现. 胡乱分析一下,显然存在一些特定的数据可以使我们的树变得很丑:长的像一条链.那么我们的运行速度就变得比未优化的链表的速度还慢:链表只需要遍历其中一条,而我们需要遍历两条.下面,我们将针对这种情况进行优化,我们可以看到如何用简洁的几条语句完成优化,甚至使我们的查询和合并的时间复杂度同时被优化到近似为$O(1)$. 高效并查集的实现相比并查集的初级实现,我们考虑从两个思路上出发进行优化,一个是之前使用过的,通过维护额外信息使得每次合并遍历尽量少的点,另一个则是之前没出现但同样直观的. 带权合并显然,由于每次find都需要找到祖先才会停止,而每次find运行时间正比于其进行循环的次数,而循环次数又取决于树的高度.因此,我们可以维护一个高度值.同样,我们规定一个元素所存储的高度是以这个元素为祖先的树的高度. 合并时有两种情况:当两棵树高度不同时,我们选择将矮一些的树合并进高一些的树,其总高度不会发生变化(由于合并时将一棵树的根作为另一棵树的根的父亲,被合并进来的树中的节点到根的距离将全部加1,因此选择将更矮的树和并进更高的树,这样访问这棵树,寻找祖先时最多寻找的次数不会发生改变,也就是总高度不变);而当两棵树高度相同时,可以任意合并,但其高度会增加1. 和链表实现的优化一样,这个优化同样只需要为数不多的语句: 1234567891011121314151617181920212223242526272829303132333435363738394041const int MAX=20010;int n;struct uf&#123; private: int f[MAX]; int h[MAX];//新定义一个额外信息的数组 int find(int a) &#123; while(f[a]!=a) a=f[a]; return a; &#125; public: void init(void) &#123; for(int i=1;i&lt;=n;i++) &#123; f[i]=i; h[i]=1;//初始化高度为1 &#125; return; &#125; bool check(int x,int y) &#123; return find(x)==find(y); &#125; void join(int x,int y) &#123; int fx=find(x); int fy=find(y); if(fx==fy) return; if(h[fx]&gt;h[fy]) fx^=fy^=fx^=fy;//保证h[fx]&lt;=h[fy] f[fx]=fy; if(h[fx]==h[fy]) h[fy]++;//如果两棵树高度相同那么合并后高度会增加1 return; &#125;&#125;; 再次尝试259. 亲戚.(由于主函数没有修改,不再给出主函数的代码) 我们又A掉了这道题.花费的时间和带优化的链表实现近似. 路径压缩我们考虑我们这种表示的最优情况:我们当然希望任何的元素都的父亲都直接就是它的祖先.这似乎很难,但我们考虑一下,是否可以在查找的过程中完成这个操作. 在查找时,我们会一路查找到祖先.那么,我们是否可能在找到祖先后将沿途经过的节点的父亲都设为找到的祖先?不难想到这么一个东西:递归. 接着用那些迷之组织来描述这一个过程.由于之前的方法找老大要经过他的手下,太麻烦了,老大希望精简管理层:所有人都由他直接领导.怎么办呢?他要求来询问自己(root)老大是谁的人(mid)在回答mid的手下(leaf)的时候,告诉leaf:以后我就不是你的领导了,我的领导以后就是你的领导了.这样,一次询问后,经过的所有人的领导就都变成了老大.計画通り. 按照这个过程,运用递归,代码很好写,只用修改find方法就行了: 12345int find(int a)&#123; if(f[a]!=a) return f[a]=find(f[a]);//当前的被询问的人不是老大,那么让他的领导再去询问,并在得知老大是谁后将自己的领导更改为原来的领导的领导(模拟一下其实就是老大) return a;//"我就是老大"&#125; 还是两行,但运用递归完成了路径的压缩.现在,只要一个节点被查询过一遍,那么在下次合并之前,就可以在$O(1)$的时间内找到它的祖先. 我们再去虐一下这道题. 同样A掉,时间和带权合并近似. 应用两种优化我们再来尝试一下同时应用两种优化.大概比只用一种优化快了$2ms$. 实践证明,一般来说只要应用一种优化就足够了.其中路径压缩代码量极小,一半推荐使用,而带权合并可以提供额外信息,更适合要求回答或是进行其他操作时需要额外信息的情况使用.(当然,代码量也不大,我倾向于都用). 完整代码如下(只有结构体的): 123456789101112131415161718192021222324252627282930313233343536373839struct uf&#123; private: int f[MAX]; int h[MAX]; int find(int a) &#123; if(f[a]!=a) return f[a]=find(f[a]); return a; &#125; public: void init(int n)//为了增强泛用性,体现数据隐藏的严谨性,我们将n作为参数传入而不是使用全局变量 &#123; for(int i=1;i&lt;=n;i++) &#123; f[i]=i; h[i]=1; &#125; return; &#125; bool check(int x,int y) &#123; return find(x)==find(y); &#125; void join(int x,int y) &#123; int fx=find(x); int fy=find(y); if(fx==fy) return; if(h[fx]&gt;h[fy]) fx^=fy^=fx^=fy; f[fx]=fy; if(h[fx]==h[fy]) h[fy]++; return; &#125;&#125;; 至此,这样一种高效的数据结构的皮毛就已经基本被掌握了.我很喜欢这个数据结构,因为它强大高效但是代码量很小(而且不会写的太丑对于我来说简直就是福音w). 例题 1.裸并查集 由于这些题目都是最基本的,没花样的并查集应用,一套代码就可以水个遍,就没有代码了. 259. 亲戚 P3367 【模板】并查集 P1551 亲戚 2.花样题 这里的题很有意思,可能不是简单的并查集,需要思考和分析.(但请相信,这些题不需要其他的数据结构).题解会有,但是可能是有生之年,还是去看看别人的吧. P1525 关押罪犯 P1196 [NOI2002]银河英雄传说 umm暂时就这些了. 后记简单的并查集是很简单的.而经过一些技巧性的操作,它可以很强大.但是它最大的特点仍是代码量极小而高效(即使是加上了技巧性的操作). 更高级的操作?可持久化?ummm…还没研究,大概是有生之年了. 请路过的大犇如果发现了我文中的错误或是不严谨的地方一定在评论中告诉我,感激不尽. 本蒟蒻在此鞠躬.]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡树之Treap]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%B9%B3%E8%A1%A1%E6%A0%91%E4%B9%8BTreap%2F</url>
    <content type="text"><![CDATA[Treap,很奇怪的名字.但是如果能拆成Tree+heap,那么就好理解了:既是树(二叉搜索树),又是堆(最大最小随意,本文中将使用最小堆). Treap是非常暴力的一种平衡树实现,它利用一个随机值,在按照二叉搜索树的规则插入元素之后再(如果必要)通过旋转维持堆的性质,提供不确定的变形机会,避免出现树高为$O(n)$的最坏情况.事实上,Treap的期望高度为$O(log\;n)$.因为暴力,所以其并不能保证绝不会出现最坏的情况,但出现最坏情况的几率极小(据说甚至远小于电脑被闪电击中的几率?),而且实现简单,因此很好用. 需要注意的是,数据遵守的是二叉搜索树的规则,而随机权值遵守的是堆的规则. 前置知识 二叉搜索树 递归 引用 结构定义由于链式结构看起来太复杂,而且应用引用可以大大的简化代码,我们不定义结构体,而是使用一系列数组.定义如下: 123456789const int MAX=10010; //数据范围来自洛谷上的普通平衡树,连接下面有int rear=1; //下一个新开节点的下标int val[MAX]; //节点存储的值int w[MAX];int cnt[MAX]; //节点存储的值重复的次数int size[MAX]; //以节点为根的子树规模(总值数量,包括重复)int lt[MAX]; //节点的左孩子int rt[MAX]; //节点的右孩子//特殊的,我们令lt[0]指向根节点(其实没必要),有效的节点下标不为0 很明显,我们在结构中定义了一般的平衡树不必须的数据size.事实上,我们会维护这个数据以进行数据的”排名”的统计和查找特定排名的元素. 在这里,代码实现的功能以及一些细节取决于洛谷上的P3369 【模板】普通平衡树（Treap/SBT）. Treap的各种操作基本操作首先,我们需要多次更新节点的size值.我们定义一个函数来简化代码.函数接受一个指向节点的指针作为参数,按照其左右子树(如果存在)的信息更新自身的size值,无返回值.为了提高效率,函数将被定义为内联函数.函数假设传入的指针不指向NULL. 1234567inline void updata(const int&amp; k)&#123; size[k]=cnt[k]; if(lt[k]) size[k]+=size[lt[k]]; if(rt[k]) size[k]+=size[rt[k]]; return;&#125; 不难看出,由于没有改变任何树的结构,updata操作不会导致Treap的性质遭到破坏. 为了保持堆的特性同时不影响搜索树的性质,我们再定义一种操作:旋转.旋转分为左旋转和右旋转,具体操作如图: 这一对操作是对称的.对照图示,代码不难写出.代码中,我们传入指向上方节点的下标指针的引用来简化代码.函数同样定义为内联函数.在左,右旋转函数中,我们分别假设参数所指向的节点的右,左孩子不为空(事实上,我们会看到,在之后的代码中只有满足这一条件是才会进行旋转). 123456789101112131415161718192021inline void left_rot(int&amp; k)&#123; int t=rt[k]; rt[k]=lt[t]; lt[t]=k; size[t]=size[k]; updata(k); k=t;//运用引用的性质直接更新指针 return;&#125;inline void right_rot(int&amp; k)&#123; int t=lt[k]; lt[k]=rt[t]; rt[t]=k; size[t]=size[k]; updata(k); k=t; return;&#125; 这就是Treap新增的(updata似乎都不算新增的)基本操作.这些将帮助我们再各种操作中保持这棵树的性质.关于旋转不会影响整棵树的性质的证明是显然的,懒,不证明了. 插入数据这是二叉搜索树的基本操作.在Treap中,它的前半部分操作和搜索树是几乎一样的,只是增加了为w(随机权重)赋值.因此这部分操作直接给出代码,简单注释.事实上,Treap仅在原来的基础上添加了两句话,意义是相同的:如果插入节点的随机权值破坏了结构,用适当的旋转修正之. 123456789101112131415161718192021222324252627void insert_val(int v,int&amp; t=lt[0]) //同样使用引用,用默认值简化调用代码&#123; if(t==0)//到了叶子节点 &#123; val[rear]=v; w[rear]=rand();//调用随机函数提供随机权重 cnt[rear]=1;//只有一个 size[rear]=1; lt[rear]=rt[rear]=0; t=rear++;//修改指针,移动边界 return; &#125; size[t]++;//无论何种情况,当前节点的size一定会加1 if(val[t]==v)//这个值已经存在了 &#123; cnt[t]++; return; &#125; if(val[t]&gt;v)&#123; insert_val(v,lt[t]); if(w[lt[t]]&lt;w[t]) right_rot(t);//出现不当的结构,旋转修复 &#125;else&#123; insert_val(v,rt[t]); if(w[rt[t]]&lt;w[t]) left_rot(t);//同上,注意旋转方向 &#125; return;&#125; 不难看出,插入操作可以在$O(h)$的时间内完成,其中$h$是这棵树的高度.而之前已经提到过,Treap的期望高度是$O(log\;n)$,因此插入操作的时间复杂度是$O(log\;n)$. 删除数据在Treap上删除数据首先可以分为两种情况,该数据重复多次或是只出现了一次.对于第一种情况,我们只需要更新size的值并对目标节点k执行cnt[k]--即可,是相当简单的.而另一种情况又可以分为三种情况: 当前节点没有任何子节点 当前节点只有一个子节点 当前节点有两个子节点 对于第一种情况,只需要利用引用直接修改其父节点的指针,直接删除当前节点就可以了; 对于第二种情况,直接用那个子节点替换当前节点即可; 对于第三种情况,稍稍有些棘手,我们有两种方式处理这种情况. 第一种方法是直接使用当前节点的前驱节点或是后继节点取代当前节点,这种方法的正确性很显然,效率也很优,但我们这里不会使用这种方法,因为这种方法会导致代码变得复杂而且会增加较多的常数(我承认是我太蒻导致的). 前驱:比当前节点的值小的最大节点 后继:比当前节点的值大的最小节点 另一种方法是按照保持Treap结构要求的方式不断旋转当前节点,递归的删除当前节点,直到某次旋转后满足以上的其他情况,此时即可直接删除.这种方法的正确性同样显然,因此我同样不打算加以证明.在这里我们使用这种方式删除节点. 在删除过程中,我们同样需要维护节点的size值.但是我们不能在向下的过程中就草率的修改途径节点的size值,因为我们没有得到被删除的值一定存在的保证.因此,我们定义删除函数的返回值为bool型,在成功删除后返回true,否则返回false,这样就可以在返回时完成对size的维护. 按照以上的讨论,我们可以写出这样的代码. 1234567891011121314151617181920212223242526272829bool del_val(int v,int t=lt[0])&#123; if(t==0) return false;//删除的值不存在 if(val[t]==v)//当前节点要删除 &#123; if(cnt[t]&gt;1) &#123; cnt[t]--;//重复了超过一次 size[t]--; return true; &#125; if(!lt[t] || !rt[t]) t=lt[t]+rt[t];//有至少一个子节点为空,直接用另一个取代当前节点 else&#123; if(w[lt[t]]&gt;w[rt[t]])&#123; left_rot(t);//适当的旋转 del_val(v,lt[t]);//递归删除 &#125;else&#123; right_rot(t); del_val(v,rt[t]); &#125; updata(t);//不要忘记更新当前节点的数据 return true; &#125; bool tmp;//保存返回值 if(val[t]&gt;v) tmp=del_val(v,lt[t]);//递归的进行删除 else tmp=del_val(v,rt[t]); if(tmp) size[t]--;//如果需要,进行更新 return tmp;&#125; 由于在递归调用过程中当前节点指针总是向下移动的,因此最多会进行$O(h)$次递归调用,删除元素的时间复杂度也就是$O(h)=O(log\;n)$. 至此,我们已经完成了Treap中最复杂的一部分:Treap结构和性质的维护.之后实现的所有操作都是不会修改任何值的. 求某数的排名首先,对排名加以定义如下: 数k的排名是:当前存在的比k小的数的数量+1. 例如:在动态集合(是不是动态集合似乎在这里没关系诶)${1,5,2,3,8,6,4,9,5,5}$中,$5$的排名是5. 我们注意到,在一棵以k所在节点为根的子树中,k的排名就是这个节点的左孩子的size值加上1(视左孩子为空的情况为左孩子的size值为1).因此, 我们可以从树根向下递归的进行求解.任意时刻的情况可以分为三种(设当前节点为k): 当前节点的值就是要进行排名的值对于这种情况,直接返回size[lt[k]]+1就好了.注意处理lt[k]==0的情况. 当前节点的值大于要排名的节点这种情况下直接求要排名的值在当前节点的左子树中的排名就可以了. 当前节点的值小于要排名的值这种情况比前两种稍微复杂一点.在这种情况下,当前节点的左子树中的所有值以及当前结点本身都是小于要排名的值的.因此结果应该是当前节点的左子树大小加上当前节点的值重复出现的次数再加上要排名的值在当前节点右子树中的排名. 这几种情况都不难处理,因此排名的代码非常简单: 123456789101112int rank_val(int v,int k=lt[0])//由于不会修改,不再使用引用&#123; if(k==0) return -1;//查询的值不存在(然而并没有写相应的处理这个错误的代码) if(val[k]==v) &#123; if(lt[k]) return size[lt[k]]+1;//umm并没有很好的利用哨兵节点 return 1; &#125; if(val[k]&gt;v) return rank_val(v,lt[k]); if(lt[k]) return size[lt[k]]+cnt[k]+rank_val(v,rt[k]); return cnt[k]+rank_val(v,rt[k]);&#125; 同样,一次操作中最多由树根进行到叶子节点,每层只会执行$O(1)$条指令,因此时间复杂度仍是$O(h)=O(log\;n)$. 查询排名为某值的数这个操作实质上和上一个操作的思路是几乎相同的,因此这里不再重复思路,直接上代码. 123456789101112int kth_val(int rank,int k=lt[0])&#123; if(k==0) return -1; if(lt[k]) &#123; if(rank&lt;=size[lt[k]]) return kth_val(rank,lt[k]);//排名不超过左子树大小的数一定就是左子树中这个排名的数 rank-=size[lt[k]];//除去左子树中的数,现在要找的是当前节点和其右子树中的排名为rank的数 &#125; if(rank&lt;=cnt[k]) return val[k]; rank-=cnt[k];//再除去当前节点的数 return kth_val(rank,rt[k]);&#125; 同理,时间复杂度为$O(log\;n)$. 查询某个数的前驱设所查询的某个数为v. 我们采用一个非常直观的思路:一路查询到v并继续查询其左子树直到叶子节点,维护其中路径上遇到的小于v的最大值,那就是我们所要查询的v的前驱.查询过程和在普通二叉搜索树中查找某个特定值几乎一样,只是增加了对最大值的维护.代码如下: 1234567891011int pre_val(int v,int k=lt[0])&#123; if(k==0) return 0x7fffffff+1;//到达叶子节点,返回极小值以消除影响(通过自然溢出) int ans=0x7fffffff+1; if(val[k]&lt;v)//当前值可能是v的前驱 &#123; ans=max(ans,val[k]); return max(ans,pre_val(v,rt[k]);//递归调用并返回找到的最大的值(向右子树找更大的值) &#125; return pre_val(v,lt[k]);//递归调用,向左子树找更小的值&#125; 查询某个数的后继和上一个操作的思路完全一样.将max变为min,将l和r以及小于号还有极值反转,就获得了查询后继的代码: 1234567891011int nex_val(int v,int k=lt[0])&#123; if(k==0) return 0x7fffffff; int ans=0x7fffffff; if(val[k]&gt;v) &#123; ans=min(ans,val[k]); return min(ans,nex_val(v,lt[k]);//递归调用并返回找到的最大的值(向右子树找更大的值) &#125; return nex_val(v,rt[k]);//递归调用,向左子树找更小的值&#125; 同理,不难得出,求前驱和后继的操作的时间复杂度都是$O(log\;n)$. 完整模板代码将上面的操作整合起来,写好主函数(话说这个模板题的主函数好复杂,操作太多了),就得到了能够AC这道模板题的代码. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;algorithm&gt;using namespace std;const int MAX=100010;int rear=1;int val[MAX]; //存储的值int cnt[MAX]; //重复次数int size[MAX]; //子树大小int w[MAX]; //随机权重//使用lt[0]指向根int lt[MAX]; //左子树指针int rt[MAX]; //右子树指针inline void updata(int k) //更新子树大小&#123; size[k]=cnt[k]; if(lt[k]!=0) size[k]+=size[lt[k]]; if(rt[k]!=0) size[k]+=size[rt[k]]; return;&#125;inline void left_rot(int &amp;k) //左旋转&#123; int t=rt[k]; rt[k]=lt[t]; lt[t]=k; size[t]=size[k]; updata(k); k=t; return;&#125;inline void right_rot(int &amp;k) //右旋转&#123; int t=lt[k]; lt[k]=rt[t]; rt[t]=k; size[t]=size[k]; updata(k); k=t; return;&#125;void insert_val(int v,int&amp; t=lt[0]) //插入&#123; if(t==0) //树中无值为val的节点,需要创建 &#123; val[rear]=v; cnt[rear]=1; size[rear]=1; w[rear]=rand(); lt[rear]=0; rt[rear]=0; t=rear++; //利用引用直接修改父节点的相应指针精简代码 return; &#125; size[t]++; //无论如何进行,t的size一定增加1 if(val[t]==v)&#123;cnt[t]++;return;&#125; //值为val的点被找到了,直接累加出现次数 if(val[t]&gt;v)&#123; insert_val(v,lt[t]); if(w[lt[t]]&lt;w[t]) right_rot(t); //如果必要进行旋转 &#125;else&#123; insert_val(v,rt[t]); if(w[rt[t]]&lt;w[t]) left_rot(t); //如果必要进行旋转 &#125; return;&#125;bool del_val(int v,int&amp; t=lt[0])&#123; if(t==0) return false; //val并不存在 if(val[t]==v) //找到了,要删除了 &#123; if(cnt[t]&gt;1)&#123;cnt[t]--;size[t]--;return true;&#125; //如果还存在val直接返回 if(!lt[t] || !rt[t]) t=lt[t]+rt[t]; //如果有一个子节点为空,直接用另一个取代当前节点 else&#123; if(w[lt[t]]&gt;w[rt[t]])&#123; right_rot(t); del_val(v,rt[t]); &#125;else&#123; left_rot(t); del_val(v,lt[t]); &#125; updata(t); &#125; return true; &#125;else&#123; bool tmp; if(v&gt;val[t]) tmp=del_val(v,rt[t]); else tmp=del_val(v,lt[t]); if(tmp) size[t]--; return tmp; &#125;&#125;int rank_val(int v,int k=lt[0])&#123; if(k==0) return -1; //不存在 if(val[k]==v) &#123; if(lt[k]!=0) return size[lt[k]]+1; return 1; &#125; if(val[k]&gt;v) return rank_val(v,lt[k]); if(lt[k]!=0) return size[lt[k]]+cnt[k]+rank_val(v,rt[k]); return cnt[k]+rank_val(v,rt[k]);&#125;int kth_val(int rank,int k=lt[0])&#123; if(k==0) return -1; if(lt[k]!=0) &#123; if(size[lt[k]]&gt;=rank) return kth_val(rank,lt[k]); rank-=size[lt[k]]; &#125; if(rank&lt;=cnt[k]) return val[k]; rank-=cnt[k]; return kth_val(rank,rt[k]);&#125;int pre_val(int v,int k=lt[0])&#123; if(k==0) return 0x7fffffff+1; int ans=0x7fffffff+1; if(val[k]&lt;v) &#123; ans=max(ans,val[k]); return max(ans,pre_val(v,rt[k])); &#125; return pre_val(v,lt[k]);&#125;int nex_val(int v,int k=lt[0])&#123; if(k==0) return 0x7fffffff; int ans=0x7fffffff; if(val[k]&gt;v) &#123; ans=min(ans,val[k]); return min(ans,nex_val(v,lt[k])); &#125; return nex_val(v,rt[k]);&#125;int main()&#123; srand(time(0));//不要忘了设置随机种子! int n,opt,v; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;opt,&amp;v); switch(opt) &#123; case 1: insert_val(v); break; case 2: del_val(v); break; case 3: printf("%d\n",rank_val(v)); break; case 4: printf("%d\n",kth_val(v)); break; case 5: printf("%d\n",pre_val(v)); break; case 6: printf("%d\n",nex_val(v)); break; default: break; &#125; &#125; return 0;&#125; 对完整代码的(胡乱)分析复杂度对于包含n个节点的Treap,其各种操作的时间复杂度在期望意义上都可以在不超过$O(log\;n)$的时间内完成.这一点由随机化保证,因此存在出现效率不佳的情况的可能,但其概率极小.而且很容易得到,即使在数个深度较小的节点处出现了只有一侧子树的情况,其对整体的性能影响也是很小的.因此,即使Treap只是一个平衡树的 “暴力”实现,也可以对其性能有坚定的信心. 进一步优化虽然上面的代码保证了Treap的正确性和一定的运行效率,我们还能做的更好.主要有以下几方面可以进行优化. 替换随机函数确实,C++提供的rand()函数比较方便,但它略大的常数也成为了影响效率的因素(虽然不很明显).因此,可以考虑手写随机函数加以替代.比如这样(原理自行百度,很容易就能找到): 12345int seed=1583;//随机种子的初始值也可以随意inline int rand()&#123; return seed = (int)((((seed ^ 998224373) + 19330819ll) * 19870803ll) % 1000000007); //其实这句中return seed=后面的表达式是可以随便写的,但会影响生成随机数的质量&#125; 构造内存池可以注意到,即使有些节点被删除了,占用的空间也不会被释放:插入新节点时仍会开辟新的空间.这就造成了所谓的内存泄漏.在上面提到的题目中这个问题并不会影响什么,但是作为一个目的是稳定高效的数据结构,同时作为一个好习惯,应该高度关注内存泄漏.因此,可以再实现一个内存池来解决这个问题(不要问我为什么不用链式结构.感觉太丑了). 这个问题中的内存池只需要利用栈或队列之类的数据结构保存被删除释放的空间信息(下标),并在请求时返回相应的值即可.比如这样: 1234567891011121314151617181920212223242526272829struct mem//想不好名字可还行&#123; private: queue&lt;int&gt; q; int rear;//就是之前代码中的rear public: mem() &#123; rear=1;//初始化 &#125; void free(int t)//释放内存 &#123; q.push(t); return; &#125; int allocate(void)//分配内存 &#123; if(!q.empty())//优先分配之前释放的内存 &#123; int tmp=q.front(); q.pop(); return tmp; &#125; rear++; return rear; &#125;&#125;; 之后在之前代码中创建新节点的地方改用mem.allocate()(虽然不可能,还是假设这就是对象名)获取内存,在适当的地方添加mem.free()释放内存. 修改为迭代形式当树很高时(虽然一般你会先超时),递归可能带来栈溢出.而且即使不会,在多数计算机上运行时,递归的效率也一般低于迭代.因此,将递归改为用while循环完成的迭代形式在某些情况下是不错的主意(但是不推荐在不必要时进行,因为这样会导致代码量提升). 封装为结构体在单一的程序中其实没什么必要(尤其是只是为了AC上面的题的话),但是封装进结构体可以让其更直观的作为一种数据结构出现,同时也是当需要操作多个Treap时的最佳选择. 后记虽然是非常暴力的随机化思想,但是无可否认,这样完成的Treap的效率确实很高,而且也很难被卡:甚至作者自己都不知道自己的Treap会干些什么.在一般情况下,为了实现上面题目中的操作,Treap应该会是我的首选吧. 如果哪里出现了什么错误,请路过的大犇不吝赐教,多谢了.]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>平衡树</tag>
        <tag>随机算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图匹配]]></title>
    <url>%2F2018%2F03%2F25%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[umm,本来是作业,介绍一个自己感兴趣的知识,于是写了篇画风诡异的,懒得改了,直接当我的二分图匹配的匈牙利算法的学习笔记吧(怠惰哦)(我完全不知道卡什是谁…) さあ、王の話をするとしよう！ 来讲一个王的故事吧. 降临众所周知,情人节快到了. 什么?情人节已经过了?没关系,我们加一个定语. 众所周知,月球人的情人节快到了. 更加充分一点: 众所周知,生活在中国的月球人的情人节快到了. 在这段万众瞩目的时间里,恐怕会发生很多很有意思的事情吧. 但不幸的是,本该在这期间有所行动的人们很多还不知道该将目标指向谁. 而幸运的是,你出现了.你有一个大胆的设想:按照身边人相互的好感关系,将尽可能多对相互都有好感的男女(忽略其他情况)”匹配”在一起,造福大众! 等等,哪里不对吧.你如何准确的得知身边的人中,谁和谁互有好感? 再等等,为什么你要干这种事?为了自己附近方圆百米只有自己一条单身狗?”旺旺”?似乎解释不通. 让我们来修改一下设定. 你是一个来拯救迷茫的人们的迷之造访者(喂,迷字用得多了点).你用卡什之眼(???)的力量得知了所需要的好感关系.你要做的还是一样,将尽可能多对相互都有好感的男女”匹配”在一起,造福大众,让他们铭记你,感激你,赞颂你. 然而然而在你提出这个大胆的构想之后,你终于发现,你太天真了.虽然身边的人不多,只有$10^1$数量级,但是他们之间的关系最多可以达到$10^2$数量级.而这些关系之间还会互相影响,实在是太过复杂,对于年幼而不擅长数学的你,实在是有些强人所难了.但是之前你已经说过了,”包在我身上了”,看来是没办法了.终究还是不行. 转机就在你几乎放弃的时候,你听说了一种魔术形式:程序.这是一种运行于被称为计算机的魔术介质上的一种东西.使用被正确配置的程序可以迅速完成需要的计算,即使需要考虑的情况复杂.正是智慧,力量,魔术的完美结合.你的眼中仿佛出现了高光.希望!看到希望了!终究,我还是要成为被称颂的王的人! 希望背后当你找到了新世界大门的时候,难以抑制的兴奋感迎面而来.但是,你突然意识到:你没有新世界大门的钥匙.虽然整个方法是存在的,利用那种魔术可以解决这个问题,但你没能力完成它的前提:你没法绘制出正确配置的程序.看着新世界的大门,上面的锁孔,高光消失了.终究还是无能为力…吗? 指引“即使这样说显得很自作多情,但我还是要说,那就是命运的邂逅.”那时,你,和一个至今还不知从哪里来,到哪里去,为了什么而出现的,自称梅莉的人物,邂逅于门前. “哦哦,这样啊,我了~解了.我问你,如果一定要你自己完成的话,你会怎么做呢?比如像这样~?”梅莉边说边画出了一幅简单的关系图,问道. [解说:图上左边的点分别表示男一,男二,男三,男四,右边的是女一,女二,女三,女四(心疼女四半秒),线表示两人互有好感] “嗯…这张图倒是简单.那么,先把男一和女一分配到一起吧.” “正解!下面呢?” “嗯,那么再把男二和女二配成一对吧!” “嗯,嗯.” “下面的话,男三…啊,和男三有好感的都被配上对了!怎么办啊!” “没关系啊,我们将之前的配对断键,试着给男三也配对啊” “哦,那么我看看…女二和男二成键了…女二还可以和…诶?女一也被分配过了!” “嗯~,那么,怎么办呢?我们手中似乎已经有了足够的工具解决这个问题了哦~“ “莫非,对于目标已经被分配了的男二,用同样的方法在进行一次吗?” “完全正确!这就是所谓的递归啊!” “再重新为男二查找,再为男一查找…啊,男一可以和女三配对,那么男二就可以和女一,男三就可以和女二了!” “果然被选中的人最棒了!” “嗯!…嗯?” “没,没什么.看,看男四怎么办!” “男四…无论怎么调整都不能配上对啊…看来需要心疼的不只是女四啊…” “嗯,没错!这样,这个问题就解决了哦~❤” “喂,为什么用那种令人起疑的语气!” “ひみつ.” 曙光&amp;王座似乎,知道了啊. 虽然很后悔没能在那个自称梅莉的人离开之前多和她说上几句话,但是至少找到了解决的方法.还真是要谢谢她.嗯…还是有些在意,有些细节… 于是,在掌握了解决问题的方法之后,你又经过了一段时间的研究,掌握了刻画能够在魔法介质上工作的魔术的方法.终于,能实现了. 你叫来了那些人,向他们展示了自己的成果,并解释了一些细节. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;//每个人本有一个编号//但是为了能够处理问题//必须将男女分别从1到n(男生数),m(女生数)编号//因此需要对照表const int id[]=&#123;0,1,2,3,6,7,10,13,16,18,19,21,23,24,25,26,27,32,35,36,38,41,4,5,8,9,11,12,14,15,17,19,20,22,28,29,30,31,33,34,37,39,40&#125;;const int MAX=1010&lt;&lt;1;int n,m; //意义见上面int map[MAX][MAX]; //用于表示关系int pi_bond[MAX]; //记录配对的人是谁bool failed[MAX];//一次寻找中如果某个人无法重新配对//那么这次寻找中他将始终无法重新配对//因此加以记录可以节省时间bool find(int x) //为男x配对.返回是否成功&#123; for(int i=n+1;i&lt;=n+m;i++) if(map[x][i]) //尝试每个可能情况 &#123; if(!pi_bond[i]) &#123; pi_bond[i]=x; //男x与女i配对成功 return true; &#125; if(!failed[i]) //可能能重新配对 &#123; if(pi_bond[i]!=x &amp;&amp; find(pi_bond[i]))&#123; pi_bond[i]=x; //重新配对成功了 return true; &#125;else&#123; failed[i]=1; //失败了 &#125; &#125; &#125; return false; //完全不行啊&#125;int main()&#123; int x,y,e; scanf("%d%d%d",&amp;n,&amp;m,&amp;e); //读入男女数和关系数 for(int i=1;i&lt;=e;i++) &#123; scanf("%d%d",&amp;x,&amp;y); //男x与女y互有好感 if(y&lt;=m) map[x][n+y]=1; //记录 &#125; int ans=0; //记录最大匹配数 for(int i=1;i&lt;=n;i++) //为男1到男n尝试匹配 &#123; memset(failed,0,sizeof(failed)); //上次不可能再次分配的这次不一定 //因此要还原 if(find(i)) ans++; //如果成功了的话就累加 &#125; printf("\nsum=%d\n",ans); //告诉大家能匹配多少对 for(int i=1;i&lt;=m;i++) &#123; if(pi_bond[n+i]) printf("%d with %d\n",id[n+i],id[pi_bond[n+i]]); else printf("%d single all the way.\n",id[n+i]); //对每对,女前男后的输出其原始编号 //对于没成功匹配的,输出... //没成功匹配的男x,抱歉,不会提到你的 &#125; return 0;&#125; 接着,你拿出了你用卡什之眼的力量(???)得到的关系表(万万没想到这有这么点): 21 20 5 4 1 4 15 5 10 9 15 16 5 然后将表提供给了设置好的程序.不负众望,你得到了结果! sum=4 4 with 6 5 single all the way. 8 single all the way. 9 single all the way. 11 with 27 12 single all the way. 14 single all the way. 15 single all the way. 17 single all the way. 19 with 7 20 single all the way. 22 single all the way. 28 single all the way. 29 single all the way. 30 with 18 31 single all the way. 33 single all the way. 34 single all the way. 37 single all the way. 39 single all the way. 人们在欢呼.仿佛划破黑暗的曙光. 而你,将加冕为王 卡什之眼你曾加冕为王. 然而,你得到的是不完全的关系图.而且最致命的是,这甚至并非是严格的”互有好感”,而只是单方面的.(真是悲伤).(不过你想想,卡什之眼什么的这种东西靠谱吗) 你离开了王座,和一位名叫akua的神见了面. 但你留下的处理这种问题的方法被人铭记,并称之为”匈牙利算法”.(真是可惜,连冠名的机会都没有). 人们仍不知道,你那天所见的,自称为梅莉的人,的真实身份. 完. 梅莉“这就是王的故事.王是不幸的.他依赖了错误的力量(所以说卡什之眼究竟是个什么鬼啊),而且最严重的是,他错误的配置了那个魔术而自己还浑然不觉.” “哦?是吗?究竟是哪里?”认真听着眼前的迷之少女讲述的王的故事的你并没有注意到问题出现在了哪里. “哈,还没看出来吗?仔细想想,会不会出现一个元素被匹配多次的情况?嘿嘿,说多了就没意思了~” “好像是这样诶.那么,其实应该怎么配置?” “像这样就可以了哦” 少女随手摆出了这样的东西. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;//每个人本有一个编号//但是为了能够处理问题//必须将男女分别从1到n(男生数),m(女生数)编号//因此需要对照表const int id[]=&#123;0,1,2,3,6,7,10,13,16,18,19,21,23,24,25,26,27,32,35,36,38,41,4,5,8,9,11,12,14,15,17,19,20,22,28,29,30,31,33,34,37,39,40&#125;;const int MAX=1010&lt;&lt;1;int n,m; //意义见上面int map[MAX][MAX]; //用于表示关系int pi_bond[MAX]; //记录配对的人是谁bool visited[MAX]; //在本次搜索中是否被访问过bool find(int x) //为男x配对.返回是否成功&#123; for(int i=n+1;i&lt;=n+m;i++) if(map[x][i] &amp;&amp; !visited[i]) //尝试每个可能情况 &#123; visited[i]=1;//标记已访问 if(!pi_bond[i] || find(pi_bond[i]))//i未匹配或是可以重新匹配 &#123; pi_bond[i]=x; //男x与女i配对成功 return true; &#125; &#125; return false; //完全不行啊&#125;int main()&#123; int x,y,e; scanf("%d%d%d",&amp;n,&amp;m,&amp;e); //读入男女数和关系数 for(int i=1;i&lt;=e;i++) &#123; scanf("%d%d",&amp;x,&amp;y); //男x与女y互有好感 if(y&lt;=m) map[x][n+y]=1; //记录 &#125; int ans=0; //记录最大匹配数 for(int i=1;i&lt;=n;i++) //为男1到男n尝试匹配 &#123; memset(visited,0,sizeof(visited)); //上次不可能再次分配的这次不一定 //因此要还原 if(find(i)) ans++; //如果成功了的话就累加 &#125; printf("\nsum=%d\n",ans); //告诉大家能匹配多少对 for(int i=1;i&lt;=m;i++) &#123; if(pi_bond[n+i]) printf("%d with %d\n",id[n+i],id[pi_bond[n+i]]); else printf("%d single all the way.\n",id[n+i]); //对每对,女前男后的输出其原始编号 //对于没成功匹配的,输出... //没成功匹配的男x,抱歉,不会提到你的 &#125; return 0;&#125; “像这样稍加修改,避免在一次匹配中出现重复访问同一个元素的情况,就能得到正确的结果了.” 看着她毫不费力的展示如此复杂的东西,你被折服了.你情不自禁的问出:”我能否有幸耳闻您的大名?” 银铃般的笑声.“你可以称呼我为梅莉哦~❤” 完….? umm……脑洞起来停不下来了.就这么着吧.故事(胡言乱语)算是结束了,脑洞填完了. 蒟蒻而且文笔极差的我在此鞠躬.无论是谁出于什么原因,感谢你看到这里.希望这个故事还算有趣.]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图算法</tag>
        <tag>二分图匹配</tag>
        <tag>胡言乱语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于这个蜜汁博客]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E8%9C%9C%E6%B1%81%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这篇文章主要是为了测试发布新博文以及简单描述一下这个博客. 当这篇博文被看到的时候想必就完成了第一个任务了吧. 这个博客是闲来无事自己(照着网上的教程)轻松(花了几个小时)搭建完成的.将会取代我以前使用的CSDN博客成为我新的(也是唯一的)博客.我博文的新家哦. 博客的主要内容会是我这个蒟蒻的算法和数据结构的学习笔记以及自以为是的写的题解,偶尔会出现因为所见所闻而有感而发写下的随笔(懒,几乎不会出现). 题目主要会来自于一下几个OJ(偶尔也会在一些其他的奇怪的地方水一水题): 洛谷 河南省实验中学的OJ LiberOJ 以下是我在这些OJ上的个人主页(用以印证我是个蒟蒻): luogu/hoetateyo COGS/snake COGS/subarashii(小号) LiberOJ/snake 这个博客刚刚搭建好最最基本的框架,我也是刚刚开始尝试自行搭建博客,因此一定会有很多的Bug,请路过的大佬谅解.当然,如果能在评论中告诉我就更好了,万分感谢! 关于评论,在评论时前两项信息(昵称和邮箱)是必填的(当然内容也是).邮箱不会公开,但是会用于获取你的(如果有的话) Gravatar头像 并加以展示.请善加利用.网址一栏并非必填,但是那个会决定点击你的头像会前往何处.如果你希望自己的站点被访问,可以考虑留下这个信息哦. 另外,如果使用HTTP链接访问将无法发布评论.请使用HTTPS进行访问(话说好像开了”强制HTTPS访问”诶…). 在本博客中,任何文章除非单独说明,否则均为原创文章.如果您觉得写的还说得过去,希望转载的话,那是您对我的肯定,我十分高兴,请随意,但请务必在您的文中注明其来源(如果是我的原创文章在文章下面也会有的,否则其来源会在开头写明),谢谢.您可以在左侧边栏上看到授权协议. 如果您愿意和我这个蒟蒻交换友链,我真的是乐意之至。您可以从左侧进入友链页面,直接再下面评论就好了! 接下来还要干的事 继续美化这个博客 添加一些骚操作(然而水平有限) 添加一个至少高效的展示PDF的东西(还没找到) 已经完成的事 添加评论功能(喂都不会有人看还添加评论功能呢) 把之前在 CSDN博客上的文章搬过来 把之前在洛谷博客上的文章搬过来 建立独立的友链页面 使用了域名snake.moe! 添加了点击特效(现在点击会飘字了). 啊,对了,请不要问我密码有什么用,我知道它没有用,完全起不到阻止查看内容的作用,我只是希望实现这么一个功能,看着舒服. 就是这样.]]></content>
      <categories>
        <category>备忘录</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>helloworld</tag>
        <tag>备忘录</tag>
      </tags>
  </entry>
</search>
